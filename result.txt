{"ls":[{"s":"class Solution {\n    public int carFleet(int target, int[] position, \nint[] speed) {\n \n    }\n}","lang":"Java"},{"s":"class Solution(object):\n    def carFleet(self, target, position, speed):\n        \"\"\"\n        :type target: int\n        :type position: List[int]\n        :type speed: List[int]\n        :rtype: int\n        \"\"\"","lang":"Python"},{"s":"class Solution:\n    def carFleet(self, target: int, position: List\n[int], speed: List[int]) -> int:","lang":"Python3"},{"s":"int carFleet(int target, int* position, int \npositionSize, int* speed, int speedSize){\n \n}","lang":"C"},{"s":"public class Solution {\n    public int CarFleet(int target, int[] position, \nint[] speed) {\n \n    }\n}","lang":"C#"},{"s":"/**\n * @param {number} target\n * @param {number[]} position\n * @param {number[]} speed\n * @return {number}\n */\nvar carFleet = function(target, position, speed) {\n \n};","lang":"JavaScript"}],"h":"853. 车队","d":"N  辆车沿着一条车道驶向位于 target 英里之外的共同目的地。\n\n每辆车 i 以恒定的速度 speed[i] （英里/小时），从初始位置 position[i] （英里） 沿车道驶向目的地。\n\n一辆车永远不会超过前面的另一辆车，但它可以追上去，并与前车以相同的速度紧接着行驶。\n\n此时，我们会忽略这两辆车之间的距离，也就是说，它们被假定处于相同的位置。\n\n车队 是一些由行驶在相同位置、具有相同速度的车组成的非空集合。注意，一辆车也可以是一个车队。\n\n即便一辆车在目的地才赶上了一个车队，它们仍然会被视作是同一个车队。\n\n \n\n会有多少车队到达目的地?\n\n \n\n示例：\n\n输入：target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]\n输出：3\n解释：\n从 10 和 8 开始的车会组成一个车队，它们在 12 处相遇。\n从 0 处开始的车无法追上其它车，所以它自己就是一个车队。\n从 5 和 3 开始的车会组成一个车队，它们在 6 处相遇。\n请注意，在到达目的地之前没有其它车会遇到这些车队，所以答案是 3。\n\n\n\n提示：\n\n0 <= N <= 10 ^ 4\n0 < target <= 10 ^ 6\n0 < speed[i] <= 10 ^ 6\n0 <= position[i] < target\n所有车的初始位置各不相同。","l":"中等","s":"/**\n * @param {number} target\n * @param {number[]} position\n * @param {number[]} speed\n * @return {number}\n */\nvar carFleet = function(target, position, speed) {\n \n};","lang":"JavaScript","bb":{"x":445,"y":40}}

{"ls":[{"s":"class Solution {\n    public int[] loudAndRich(int[][] richer, int[] \nquiet) {\n \n    }\n}","lang":"Java"},{"s":"class Solution(object):\n    def loudAndRich(self, richer, quiet):\n        \"\"\"\n        :type richer: List[List[int]]\n        :type quiet: List[int]\n        :rtype: List[int]\n        \"\"\"","lang":"Python"},{"s":"class Solution:\n    def loudAndRich(self, richer: List[List[int]], \nquiet: List[int]) -> List[int]:","lang":"Python3"},{"s":"/**\n * Note: The returned array must be malloced, \nassume caller calls free().\n */\nint* loudAndRich(int** richer, int richerSize, int* \nricherColSize, int* quiet, int quietSize, int* \nreturnSize){\n \n}","lang":"C"},{"s":"public class Solution {\n    public int[] LoudAndRich(int[][] richer, int[] \nquiet) {\n \n    }\n}","lang":"C#"},{"s":"/**\n * @param {number[][]} richer\n * @param {number[]} quiet\n * @return {number[]}\n */\nvar loudAndRich = function(richer, quiet) {\n \n};","lang":"JavaScript"}],"page":"851/1581","h":"851. 喧闹和富有","d":"在一组 N 个人（编号为 0, 1, 2, ..., N-1）中，每个人都有不同数目的钱，以及不同程度的安静（quietness）。\n\n为了方便起见，我们将编号为 x 的人简称为 \"person x \"。\n\n如果能够肯定 person x 比 person y 更有钱的话，我们会说 richer[i] = [x, y] 。注意 richer 可能只是有效观察的一个子集。\n\n另外，如果 person x 的安静程度为 q ，我们会说 quiet[x] = q 。\n\n现在，返回答案 answer ，其中 answer[x] = y 的前提是，在所有拥有的钱不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。\n\n示例：\n\n输入：richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]\n输出：[5,5,2,5,4,5,6,7]\n解释： \nanswer[0] = 5，\nperson 5 比 person 3 有更多的钱，person 3 比 person 1 有更多的钱，person 1 比 person 0 有更多的钱。\n唯一较为安静（有较低的安静值 quiet[x]）的人是 person 7，\n但是目前还不清楚他是否比 person 0 更有钱。\n\nanswer[7] = 7，\n在所有拥有的钱肯定不少于 person 7 的人中(这可能包括 person 3，4，5，6 以及 7)，\n最安静(有较低安静值 quiet[x])的人是 person 7。\n\n其他的答案也可以用类似的推理来解释。\n\n\n提示：\n\n1 <= quiet.length = N <= 500\n0 <= quiet[i] < N，所有 quiet[i] 都不相同。\n0 <= richer.length <= N * (N-1) / 2\n0 <= richer[i][j] < N\nricher[i][0] != richer[i][1]\nricher[i] 都是不同的。\n对 richer 的观察在逻辑上是一致的。","l":"中等","s":"class Solution {\npublic:\n    vector<int> loudAndRich(vector<vector<int>>& \nricher, vector<int>& quiet) {\n \n    }\n};","lang":"C++","bb":{"x":490,"y":50}}

{"ls":[{"s":"class Solution {\n    public int peakIndexInMountainArray(int[] A) {\n \n    }\n}","lang":"Java"},{"s":"class Solution(object):\n    def peakIndexInMountainArray(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"","lang":"Python"},{"s":"class Solution:\n    def peakIndexInMountainArray(self, A: List[int])\n -> int:","lang":"Python3"},{"s":"int peakIndexInMountainArray(int* A, int ASize){\n \n}","lang":"C"},{"s":"public class Solution {\n    public int PeakIndexInMountainArray(int[] A) {\n \n    }\n}","lang":"C#"},{"s":"/**\n * @param {number[]} A\n * @return {number}\n */\nvar peakIndexInMountainArray = function(A) {\n \n};","lang":"JavaScript"}],"page":"852/1581","h":"852. 山脉数组的峰顶索引","d":"我们把符合下列属性的数组 A 称作山脉：\n\nA.length >= 3\n存在 0 < i < A.length - 1 使得A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]\n\n给定一个确定为山脉的数组，返回任何满足 A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1] 的 i 的值。\n\n \n\n示例 1：\n\n输入：[0,1,0]\n输出：1\n\n\n示例 2：\n\n输入：[0,2,1,0]\n输出：1\n\n \n\n提示：\n\n3 <= A.length <= 10000\n0 <= A[i] <= 10^6\nA 是如上定义的山脉\n\n ","l":"简单","s":"/**\n * @param {number[]} A\n * @return {number}\n */\nvar peakIndexInMountainArray = function(A) {\n \n};","lang":"JavaScript","bb":{"x":445,"y":40}}

{"ls":[{"s":"class Solution {\n    public int carFleet(int target, int[] position, \nint[] speed) {\n \n    }\n}","lang":"Java"},{"s":"class Solution(object):\n    def carFleet(self, target, position, speed):\n        \"\"\"\n        :type target: int\n        :type position: List[int]\n        :type speed: List[int]\n        :rtype: int\n        \"\"\"","lang":"Python"},{"s":"class Solution:\n    def carFleet(self, target: int, position: List\n[int], speed: List[int]) -> int:","lang":"Python3"},{"s":"int carFleet(int target, int* position, int \npositionSize, int* speed, int speedSize){\n \n}","lang":"C"},{"s":"public class Solution {\n    public int CarFleet(int target, int[] position, \nint[] speed) {\n \n    }\n}","lang":"C#"},{"s":"/**\n * @param {number} target\n * @param {number[]} position\n * @param {number[]} speed\n * @return {number}\n */\nvar carFleet = function(target, position, speed) {\n \n};","lang":"JavaScript"}],"page":"853/1581","h":"853. 车队","d":"N  辆车沿着一条车道驶向位于 target 英里之外的共同目的地。\n\n每辆车 i 以恒定的速度 speed[i] （英里/小时），从初始位置 position[i] （英里） 沿车道驶向目的地。\n\n一辆车永远不会超过前面的另一辆车，但它可以追上去，并与前车以相同的速度紧接着行驶。\n\n此时，我们会忽略这两辆车之间的距离，也就是说，它们被假定处于相同的位置。\n\n车队 是一些由行驶在相同位置、具有相同速度的车组成的非空集合。注意，一辆车也可以是一个车队。\n\n即便一辆车在目的地才赶上了一个车队，它们仍然会被视作是同一个车队。\n\n \n\n会有多少车队到达目的地?\n\n \n\n示例：\n\n输入：target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]\n输出：3\n解释：\n从 10 和 8 开始的车会组成一个车队，它们在 12 处相遇。\n从 0 处开始的车无法追上其它车，所以它自己就是一个车队。\n从 5 和 3 开始的车会组成一个车队，它们在 6 处相遇。\n请注意，在到达目的地之前没有其它车会遇到这些车队，所以答案是 3。\n\n\n\n提示：\n\n0 <= N <= 10 ^ 4\n0 < target <= 10 ^ 6\n0 < speed[i] <= 10 ^ 6\n0 <= position[i] < target\n所有车的初始位置各不相同。","l":"中等","s":"/**\n * @param {number} target\n * @param {number[]} position\n * @param {number[]} speed\n * @return {number}\n */\nvar carFleet = function(target, position, speed) {\n \n};","lang":"JavaScript","bb":{"x":445,"y":40}}

