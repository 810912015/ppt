{"ls":[{"s":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int[] findMode(TreeNode root) {\n \n    }\n}","lang":"Java"},{"s":"# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n \nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"","lang":"Python"},{"s":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n \nclass Solution:\n    def findMode(self, root: TreeNode) -> List[int]:","lang":"Python3"},{"s":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n \n \n/**\n * Note: The returned array must be malloced, assume \ncaller calls free().\n */\nint* findMode(struct TreeNode* root, int* returnSize)\n{\n \n}","lang":"C"},{"s":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public int[] FindMode(TreeNode root) {\n \n    }\n}","lang":"C#"},{"s":"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar findMode = function(root) {\n \n};","lang":"JavaScript"}],"page":"501/1581","h":"501. 二叉搜索树中的众数","d":"<div class=\"notranslate\"><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p>\n\n<p>假定 BST 有如下定义：</p>\n\n<ul>\n\t<li>结点左子树中所含结点的值小于等于当前结点的值</li>\n\t<li>结点右子树中所含结点的值大于等于当前结点的值</li>\n\t<li>左子树和右子树都是二叉搜索树</li>\n</ul>\n\n<p>例如：<br>\n给定 BST <code>[1,null,2,2]</code>,</p>\n\n<pre>   1\n    \\\n     2\n    /\n   2\n</pre>\n\n<p><code>返回[2]</code>.</p>\n\n<p><strong>提示</strong>：如果众数超过1个，不需考虑输出顺序</p>\n\n<p><strong>进阶：</strong>你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p>\n</div>","l":"简单","s":"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar findMode = function(root) {\n \n};","lang":"JavaScript","href":"https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/","bb":{"x":490,"y":50}}

