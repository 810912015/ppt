{"ls":[{"s":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int[] findFrequentTreeSum(TreeNode root) {\n \n    }\n}","lang":"Java"},{"s":"# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n \nclass Solution(object):\n    def findFrequentTreeSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"","lang":"Python"},{"s":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n \nclass Solution:\n    def findFrequentTreeSum(self, root: TreeNode) -> \nList[int]:","lang":"Python3"},{"s":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n \n \n/**\n * Note: The returned array must be malloced, assume \ncaller calls free().\n */\nint* findFrequentTreeSum(struct TreeNode* root, int* \nreturnSize){\n \n}","lang":"C"},{"s":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public int[] FindFrequentTreeSum(TreeNode root) {\n \n    }\n}","lang":"C#"},{"s":"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar findFrequentTreeSum = function(root) {\n \n};","lang":"JavaScript"}],"page":"508/1581","h":"508. 出现次数最多的子树元素和","d":"<div class=\"notranslate\"><p>给出二叉树的根，找出出现次数最多的子树元素和。一个结点的子树元素和定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。然后求出出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的元素（不限顺序）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1</strong><br>\n输入:</p>\n\n<pre>  5\n /  \\\n2   -3\n</pre>\n\n<p>返回&nbsp;[2, -3, 4]，所有的值均只出现一次，以任意顺序返回所有值。</p>\n\n<p><strong>示例&nbsp;2</strong><br>\n输入:</p>\n\n<pre>  5\n /  \\\n2   -5\n</pre>\n\n<p>返回&nbsp;[2]，只有 2 出现两次，-5 只出现 1 次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong>&nbsp;假设任意子树元素和均可以用 32 位有符号整数表示。</p>\n</div>","l":"中等","s":"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar findFrequentTreeSum = function(root) {\n \n};","lang":"JavaScript","href":"https://leetcode-cn.com/problems/most-frequent-subtree-sum/","bb":{"x":490,"y":50}}

