{"ls":[{"s":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<List<String>> printTree(TreeNode \nroot) {\n \n    }\n}","lang":"Java"},{"s":"# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n \nclass Solution(object):\n    def printTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[str]]\n        \"\"\"","lang":"Python"},{"s":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n \nclass Solution:\n    def printTree(self, root: TreeNode) -> List[List\n[str]]:","lang":"Python3"},{"s":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n \n \n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as \n*returnColumnSizes array.\n * Note: Both returned array and *columnSizes array \nmust be malloced, assume caller calls free().\n */\nchar *** printTree(struct TreeNode* root, int* \nreturnSize, int** returnColumnSizes){\n \n}","lang":"C"},{"s":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public IList<IList<string>> PrintTree(TreeNode \nroot) {\n \n    }\n}","lang":"C#"},{"s":"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {string[][]}\n */\nvar printTree = function(root) {\n \n};","lang":"JavaScript"}],"page":"655/1581","h":"655. 输出二叉树","d":"<div class=\"notranslate\"><p>在一个 m*n 的二维字符串数组中输出二叉树，并遵守以下规则：</p>\n\n<ol>\n\t<li>行数&nbsp;<code>m</code>&nbsp;应当等于给定二叉树的高度。</li>\n\t<li>列数&nbsp;<code>n</code>&nbsp;应当总是奇数。</li>\n\t<li>根节点的值（以字符串格式给出）应当放在可放置的第一行正中间。根节点所在的行与列会将剩余空间划分为两部分（<strong>左下部分和右下部分</strong>）。你应该将左子树输出在左下部分，右子树输出在右下部分。左下和右下部分应当有相同的大小。即使一个子树为空而另一个非空，你不需要为空的子树输出任何东西，但仍需要为另一个子树留出足够的空间。然而，如果两个子树都为空则不需要为它们留出任何空间。</li>\n\t<li>每个未使用的空间应包含一个空的字符串<code>\"\"</code>。</li>\n\t<li>使用相同的规则输出子树。</li>\n</ol>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong>\n     1\n    /\n   2\n<strong>输出:</strong>\n[[\"\", \"1\", \"\"],\n [\"2\", \"\", \"\"]]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong>\n     1\n    / \\\n   2   3\n    \\\n     4\n<strong>输出:</strong>\n[[\"\", \"\", \"\", \"1\", \"\", \"\", \"\"],\n [\"\", \"2\", \"\", \"\", \"\", \"3\", \"\"],\n [\"\", \"\", \"4\", \"\", \"\", \"\", \"\"]]\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre><strong>输入:</strong>\n      1\n     / \\\n    2   5\n   / \n  3 \n / \n4 \n<strong>输出:</strong>\n[[\"\",  \"\",  \"\", \"\",  \"\", \"\", \"\", \"1\", \"\",  \"\",  \"\",  \"\",  \"\", \"\", \"\"]\n [\"\",  \"\",  \"\", \"2\", \"\", \"\", \"\", \"\",  \"\",  \"\",  \"\",  \"5\", \"\", \"\", \"\"]\n [\"\",  \"3\", \"\", \"\",  \"\", \"\", \"\", \"\",  \"\",  \"\",  \"\",  \"\",  \"\", \"\", \"\"]\n [\"4\", \"\",  \"\", \"\",  \"\", \"\", \"\", \"\",  \"\",  \"\",  \"\",  \"\",  \"\", \"\", \"\"]]\n</pre>\n\n<p><strong>注意:</strong> 二叉树的高度在范围 [1, 10] 中。</p>\n</div>","l":"中等","s":"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {string[][]}\n */\nvar printTree = function(root) {\n \n};","lang":"JavaScript","href":"https://leetcode-cn.com/problems/print-binary-tree/","bb":{"x":490,"y":50}}

