{"ls":[{"s":"/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    \n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    \n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    \n    public Node(int _val, ArrayList<Node> _neighbors)\n {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\nclass Solution {\n    public Node cloneGraph(Node node) {\n        ","lang":"Java"},{"s":"\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val = 0, neighbors = []):\n        self.val = val\n        self.neighbors = neighbors\n\"\"\"\nclass Solution(object):\n    def cloneGraph(self, node):\n        \"\"\"\n        :type node: Node\n        :rtype: Node\n        \"\"\"","lang":"Python"},{"s":"\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val = 0, neighbors = []):\n        self.val = val\n        self.neighbors = neighbors\n\"\"\"\nclass Solution:\n    def cloneGraph(self, node: 'Node') -> 'Node':","lang":"Python3"},{"s":"/*\n// Definition for a Node.\npublic class Node {\n    public int val;\n    public IList<Node> neighbors;\n    \n    public Node() {\n        val = 0;\n        neighbors = new List<Node>();\n    }\n \n    public Node(int _val) {\n        val = _val;\n        neighbors = new List<Node>();\n    }\n    \n    public Node(int _val, List<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\npublic class Solution {\n    public Node CloneGraph(Node node) {\n        \n    }","lang":"C#"},{"s":"/**\n * // Definition for a Node.\n * function Node(val, neighbors) {\n *    this.val = val === undefined ? 0 : val;\n *    this.neighbors = neighbors === undefined ? [] \n: neighbors;\n * };\n */\n/**\n * @param {Node} node\n * @return {Node}\n */\nvar cloneGraph = function(node) {\n    \n};","lang":"JavaScript"},{"s":"/**\n * Definition for a Node.\n * public class Node {\n *     public var val: Int\n *     public var neighbors: [Node?]\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.neighbors = []\n *     }\n * }\n */\n \nclass Solution {\n    func cloneGraph(_ node: Node?) -> Node? {\n        \n    }\n}","lang":"Swift"}],"page":"133/1581","h":"133. 克隆图","d":"<div class=\"notranslate\"><p>给你无向&nbsp;<strong><a href=\"https://baike.baidu.com/item/连通图/6460995?fr=aladdin\">连通</a>&nbsp;</strong>图中一个节点的引用，请你返回该图的&nbsp;<a href=\"https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin\"><strong>深拷贝</strong></a>（克隆）。</p>\n\n<p>图中的每个节点都包含它的值 <code>val</code>（<code>int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p>\n\n<pre>class Node {\n    public int val;\n    public List&lt;Node&gt; neighbors;\n}</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>测试用例格式：</strong></p>\n\n<p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（<code>val = 1</code>），第二个节点值为 2（<code>val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。</p>\n\n<p><strong>邻接列表</strong> 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p>\n\n<p>给定节点将始终是图中的第一个节点（值为 1）。你必须将&nbsp;<strong>给定节点的拷贝&nbsp;</strong>作为对克隆图的引用返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img style=\"height: 500px; width: 500px;\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png\" alt=\"\"></p>\n\n<pre><strong>输入：</strong>adjList = [[2,4],[1,3],[2,4],[1,3]]\n<strong>输出：</strong>[[2,4],[1,3],[2,4],[1,3]]\n<strong>解释：\n</strong>图中有 4 个节点。\n节点 1 的值是 1，它有两个邻居：节点 2 和 4 。\n节点 2 的值是 2，它有两个邻居：节点 1 和 3 。\n节点 3 的值是 3，它有两个邻居：节点 2 和 4 。\n节点 4 的值是 4，它有两个邻居：节点 1 和 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img style=\"height: 148px; width: 163px;\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph.png\" alt=\"\"></p>\n\n<pre><strong>输入：</strong>adjList = [[]]\n<strong>输出：</strong>[[]]\n<strong>解释：</strong>输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>adjList = []\n<strong>输出：</strong>[]\n<strong>解释：</strong>这个图是空的，它不含任何节点。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<p><img style=\"height: 133px; width: 272px;\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph-1.png\" alt=\"\"></p>\n\n<pre><strong>输入：</strong>adjList = [[2],[1]]\n<strong>输出：</strong>[[2],[1]]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>节点数不超过 100 。</li>\n\t<li>每个节点值&nbsp;<code>Node.val</code> 都是唯一的，<code>1 &lt;= Node.val &lt;= 100</code>。</li>\n\t<li>无向图是一个<a href=\"https://baike.baidu.com/item/简单图/1680528?fr=aladdin\">简单图</a>，这意味着图中没有重复的边，也没有自环。</li>\n\t<li>由于图是无向的，如果节点 <em>p</em> 是节点 <em>q</em> 的邻居，那么节点 <em>q</em> 也必须是节点 <em>p</em>&nbsp;的邻居。</li>\n\t<li>图是连通图，你可以从给定节点访问到所有节点。</li>\n</ol>\n</div>","l":"中等","s":"/**\n * // Definition for a Node.\n * function Node(val, neighbors) {\n *    this.val = val === undefined ? 0 : val;\n *    this.neighbors = neighbors === undefined ? [] \n: neighbors;\n * };\n */\n/**\n * @param {Node} node\n * @return {Node}\n */\nvar cloneGraph = function(node) {\n    \n};","lang":"JavaScript","href":"https://leetcode-cn.com/problems/clone-graph/","bb":{"x":490,"y":50}}

