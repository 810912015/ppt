{"ls":[{"s":"class Solution {\n    public void nextPermutation(int[] nums) {\n \n    }\n}","lang":"Java"},{"s":"class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify \nnums in-place instead.\n        \"\"\"","lang":"Python"},{"s":"class Solution:\n    def nextPermutation(self, nums: List[int]) -> \nNone:\n        \"\"\"\n        Do not return anything, modify nums in-place \ninstead.\n        \"\"\"","lang":"Python3"},{"s":"void nextPermutation(int* nums, int numsSize){\n \n}","lang":"C"},{"s":"public class Solution {\n    public void NextPermutation(int[] nums) {\n \n    }\n}","lang":"C#"},{"s":"/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify \nnums in-place instead.\n */\nvar nextPermutation = function(nums) {\n \n};","lang":"JavaScript"}],"page":"31/1581","h":"31. 下一个排列","d":"<div class=\"notranslate\"><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>\n\n<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>\n\n<p>必须<strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\">原地</a></strong>修改，只允许使用额外常数空间。</p>\n\n<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br>\n<code>1,2,3</code> → <code>1,3,2</code><br>\n<code>3,2,1</code> → <code>1,2,3</code><br>\n<code>1,1,5</code> → <code>1,5,1</code></p>\n</div>","l":"中等","s":"/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify \nnums in-place instead.\n */\nvar nextPermutation = function(nums) {\n \n};","lang":"JavaScript","href":"https://leetcode-cn.com/problems/next-permutation/","bb":{"x":490,"y":50}}

