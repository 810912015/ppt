{"ls":[{"s":"class Solution {\n    public List<List<String>> findLadders(String \nbeginWord, String endWord, List<String> wordList) {\n \n    }\n}","lang":"Java"},{"s":"class Solution(object):\n    def findLadders(self, beginWord, endWord, \nwordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"","lang":"Python"},{"s":"class Solution:\n    def findLadders(self, beginWord: str, endWord: \nstr, wordList: List[str]) -> List[List[str]]:","lang":"Python3"},{"s":"/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as \n*returnColumnSizes array.\n * Note: Both returned array and *columnSizes array \nmust be malloced, assume caller calls free().\n */\nchar *** findLadders(char * beginWord, char * \nendWord, char ** wordList, int wordListSize, int* \nreturnSize, int** returnColumnSizes){\n \n}","lang":"C"},{"s":"public class Solution {\n    public IList<IList<string>> FindLadders(string \nbeginWord, string endWord, IList<string> wordList) {\n \n    }\n}","lang":"C#"},{"s":"/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {string[][]}\n */\nvar findLadders = function(beginWord, endWord, \nwordList) {\n \n};","lang":"JavaScript"},{"s":"# @param {String} begin_word\n# @param {String} end_word\n# @param {String[]} word_list\n# @return {String[][]}\ndef find_ladders(begin_word, end_word, word_list)\n \nend","lang":"Ruby"},{"s":"class Solution {\n    func findLadders(_ beginWord: String, _ \nendWord: String, _ wordList: [String]) -> [[String]]\n {\n \n    }\n}","lang":"Swift"},{"s":"func findLadders(beginWord string, endWord string, \nwordList []string) [][]string {\n \n}","lang":"Go"},{"s":"object Solution {\n    def findLadders(beginWord: String, endWord: \nString, wordList: List[String]): List[List[String]] \n= {\n \n    }\n}","lang":"Scala"},{"s":"class Solution {\n    fun findLadders(beginWord: String, endWord: \nString, wordList: List<String>): List<List<String>> \n{\n \n    }\n}","lang":"Kotlin"},{"s":"impl Solution {\n    pub fn find_ladders(begin_word: String, \nend_word: String, word_list: Vec<String>) -> \nVec<Vec<String>> {\n \n    }\n}","lang":"Rust"},{"s":"class Solution {\n \n    /**\n     * @param String $beginWord\n     * @param String $endWord\n     * @param String[] $wordList\n     * @return String[][]\n     */\n    function findLadders($beginWord, $endWord, \n$wordList) {\n \n    }\n}","lang":"PHP"},{"s":"class Solution {\n \n    /**\n     * @param String $beginWord\n     * @param String $endWord\n     * @param String[] $wordList\n     * @return String[][]\n     */\n    function findLadders($beginWord, $endWord, \n$wordList) {\n \n    }\n}","lang":"PHP"}],"page":"126/1581","h":"126. 单词接龙 II","d":"<div class=\"notranslate\"><p>给定两个单词（<em>beginWord</em> 和 <em>endWord</em>）和一个字典 <em>wordList</em>，找出所有从 <em>beginWord </em>到 <em>endWord </em>的最短转换序列。转换需遵循如下规则：</p>\n\n<ol>\n\t<li>每次转换只能改变一个字母。</li>\n\t<li>转换过程中的中间单词必须是字典中的单词。</li>\n</ol>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li>如果不存在这样的转换序列，返回一个空列表。</li>\n\t<li>所有单词具有相同的长度。</li>\n\t<li>所有单词只由小写字母组成。</li>\n\t<li>字典中不存在重复的单词。</li>\n\t<li>你可以假设 <em>beginWord</em> 和 <em>endWord </em>是非空的，且二者不相同。</li>\n</ul>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong>\nbeginWord = \"hit\",\nendWord = \"cog\",\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n\n<strong>输出:</strong>\n[\n  [\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],\n&nbsp; [\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]\n]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong>\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n\n<strong>输出: </strong>[]\n\n<strong>解释:</strong>&nbsp;<em>endWord</em> \"cog\" 不在字典中，所以不存在符合要求的转换序列。</pre>\n</div>","l":"困难","s":"# @param {String} begin_word","lang":"Ruby","href":"https://leetcode-cn.com/problems/word-ladder-ii/","bb":{"x":445,"y":40,"w":116,"h":28}}

