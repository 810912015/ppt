{"ls":[{"s":"class RLEIterator\n \n=begin\n    :type a: Integer[]\n=end\n    def initialize(a)\n \n    end\n \n \n=begin\n    :type n: Integer\n    :rtype: Integer\n=end\n    def next(n)\n \n    end\n \n \nend\n \n# Your RLEIterator object will be instantiated and \ncalled as such:\n# obj = RLEIterator.new(a)\n# param_1 = obj.next(n)","lang":"Ruby"},{"s":"class RLEIterator {\n \n    init(_ A: [Int]) {\n        \n    }\n    \n    func next(_ n: Int) -> Int {\n        \n    }\n}\n \n/**\n * Your RLEIterator object will be instantiated and \ncalled as such:\n * let obj = RLEIterator(A)\n * let ret_1: Int = obj.next(n)\n */","lang":"Swift"},{"s":"type RLEIterator struct {\n \n}\n \n \nfunc Constructor(A []int) RLEIterator {\n \n}\n \n \nfunc (this *RLEIterator) Next(n int) int {\n \n}\n \n \n/**\n * Your RLEIterator object will be instantiated and \ncalled as such:\n * obj := Constructor(A);\n * param_1 := obj.Next(n);\n */","lang":"Go"},{"s":"class RLEIterator(_A: Array[Int]) {\n \n    def next(n: Int): Int = {\n \n    }\n \n}\n \n/**\n * Your RLEIterator object will be instantiated and \ncalled as such:\n * var obj = new RLEIterator(A)\n * var param_1 = obj.next(n)\n */","lang":"Scala"},{"s":"class RLEIterator(A: IntArray) {\n \n    fun next(n: Int): Int {\n \n    }\n \n}\n \n/**\n * Your RLEIterator object will be instantiated and \ncalled as such:\n * var obj = RLEIterator(A)\n * var param_1 = obj.next(n)\n */","lang":"Kotlin"},{"s":"struct RLEIterator {\n \n}\n \n \n/** \n * `&self` means the method takes an immutable \nreference.\n * If you need a mutable reference, change it to `&\nmut self` instead.\n */\nimpl RLEIterator {\n \n    fn new(A: Vec<i32>) -> Self {\n        \n    }\n    \n    fn next(&self, n: i32) -> i32 {\n        \n    }\n}\n \n/**\n * Your RLEIterator object will be instantiated and \ncalled as such:\n * let obj = RLEIterator::new(A);","lang":"Rust"},{"s":"class RLEIterator {\n \n    public RLEIterator(int[] A) {\n \n    }\n    \n    public int next(int n) {\n \n    }\n}\n \n/**\n * Your RLEIterator object will be instantiated and \ncalled as such:\n * RLEIterator obj = new RLEIterator(A);\n * int param_1 = obj.next(n);\n */","lang":"Java"},{"s":"class RLEIterator(object):\n \n    def __init__(self, A):\n        \"\"\"\n        :type A: List[int]\n        \"\"\"\n        \n \n    def next(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n \n \n# Your RLEIterator object will be instantiated and \ncalled as such:\n# obj = RLEIterator(A)\n# param_1 = obj.next(n)","lang":"Python"},{"s":"class RLEIterator:\n \n    def __init__(self, A: List[int]):\n        \n \n    def next(self, n: int) -> int:\n        \n \n \n# Your RLEIterator object will be instantiated and \ncalled as such:\n# obj = RLEIterator(A)\n# param_1 = obj.next(n)","lang":"Python3"},{"s":"typedef struct {\n    \n} RLEIterator;\n \n \nRLEIterator* rLEIteratorCreate(int* A, int ASize) {\n    \n}\n \nint rLEIteratorNext(RLEIterator* obj, int n) {\n  \n}\n \nvoid rLEIteratorFree(RLEIterator* obj) {\n    \n}\n \n/**\n * Your RLEIterator struct will be instantiated and \ncalled as such:\n * RLEIterator* obj = rLEIteratorCreate(A, ASize);\n * int param_1 = rLEIteratorNext(obj, n);\n \n * rLEIteratorFree(obj);\n*/","lang":"C"},{"s":"public class RLEIterator {\n \n    public RLEIterator(int[] A) {\n \n    }\n    \n    public int Next(int n) {\n \n    }\n}\n \n/**\n * Your RLEIterator object will be instantiated and \ncalled as such:\n * RLEIterator obj = new RLEIterator(A);\n * int param_1 = obj.Next(n);\n */","lang":"C#"},{"s":"/**\n * @param {number[]} A\n */\nvar RLEIterator = function(A) {\n \n};\n \n/** \n * @param {number} n\n * @return {number}\n */\nRLEIterator.prototype.next = function(n) {\n \n};\n \n/**\n * Your RLEIterator object will be instantiated and \ncalled as such:\n * var obj = new RLEIterator(A)\n * var param_1 = obj.next(n)\n */","lang":"JavaScript"},{"s":"class RLEIterator\n \n=begin\n    :type a: Integer[]\n=end\n    def initialize(a)\n \n    end\n \n \n=begin\n    :type n: Integer\n    :rtype: Integer\n=end\n    def next(n)\n \n    end\n \n \nend\n \n# Your RLEIterator object will be instantiated and \ncalled as such:\n# obj = RLEIterator.new(a)\n# param_1 = obj.next(n)","lang":"Ruby"},{"s":"class RLEIterator\n \n=begin\n    :type a: Integer[]\n=end\n    def initialize(a)\n \n    end\n \n \n=begin\n    :type n: Integer\n    :rtype: Integer\n=end\n    def next(n)\n \n    end\n \n \nend\n \n# Your RLEIterator object will be instantiated and \ncalled as such:\n# obj = RLEIterator.new(a)\n# param_1 = obj.next(n)","lang":"Ruby"}],"page":"900/1581","h":"900. RLE 迭代器","d":"<div class=\"notranslate\"><p>编写一个遍历游程编码序列的迭代器。</p>\n\n<p>迭代器由 <code>RLEIterator(int[] A)</code> 初始化，其中&nbsp;<code>A</code>&nbsp;是某个序列的游程编码。更具体地，对于所有偶数 <code>i</code>，<code>A[i]</code> 告诉我们在序列中重复非负整数值 <code>A[i + 1]</code> 的次数。</p>\n\n<p>迭代器支持一个函数：<code>next(int n)</code>，它耗尽接下来的&nbsp; <code>n</code> 个元素（<code>n &gt;= 1</code>）并返回以这种方式耗去的最后一个元素。如果没有剩余的元素可供耗尽，则&nbsp; <code>next</code>&nbsp;返回&nbsp;<code>-1</code> 。</p>\n\n<p>例如，我们以&nbsp;<code>A = [3,8,0,9,2,5]</code>&nbsp;开始，这是序列&nbsp;<code>[8,8,8,5,5]</code>&nbsp;的游程编码。这是因为该序列可以读作 “三个八，零个九，两个五”。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>[\"RLEIterator\",\"next\",\"next\",\"next\",\"next\"], [[[3,8,0,9,2,5]],[2],[1],[1],[2]]\n<strong>输出：</strong>[null,8,8,5,-1]\n<strong>解释：</strong>\nRLEIterator 由 RLEIterator([3,8,0,9,2,5]) 初始化。\n这映射到序列 [8,8,8,5,5]。\n然后调用 RLEIterator.next 4次。\n\n.next(2) 耗去序列的 2 个项，返回 8。现在剩下的序列是 [8, 5, 5]。\n\n.next(1) 耗去序列的 1 个项，返回 8。现在剩下的序列是 [5, 5]。\n\n.next(1) 耗去序列的 1 个项，返回 5。现在剩下的序列是 [5]。\n\n.next(2) 耗去序列的 2 个项，返回 -1。 这是由于第一个被耗去的项是 5，\n但第二个项并不存在。由于最后一个要耗去的项不存在，我们返回 -1。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>0 &lt;= A.length &lt;= 1000</code></li>\n\t<li><code>A.length</code>&nbsp;是偶数。</li>\n\t<li><code>0 &lt;= A[i] &lt;= 10^9</code></li>\n\t<li>每个测试用例最多调用&nbsp;<code>1000</code>&nbsp;次&nbsp;<code>RLEIterator.next(int n)</code>。</li>\n\t<li>每次调用&nbsp;<code>RLEIterator.next(int n)</code>&nbsp;都有&nbsp;<code>1 &lt;= n &lt;= 10^9</code>&nbsp;。</li>\n</ol>\n</div>","l":"中等","s":"class RLEIterator {","lang":"PHP","href":"https://leetcode-cn.com/problems/rle-iterator/","bb":{"x":445,"y":40,"w":116,"h":28}}

