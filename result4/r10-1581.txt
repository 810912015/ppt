{"ls":[{"s":"class Solution {\n    public boolean isMatch(String s, String p) {\n \n    }\n}","lang":"Java"},{"s":"class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"","lang":"Python"},{"s":"class Solution:\n    def isMatch(self, s: str, p: str) -> bool:","lang":"Python3"},{"s":"bool isMatch(char * s, char * p){\n \n}","lang":"C"},{"s":"public class Solution {\n    public bool IsMatch(string s, string p) {\n \n    }\n}","lang":"C#"},{"s":"/**\n * @param {string} s\n * @param {string} p\n * @return {boolean}\n */\nvar isMatch = function(s, p) {\n \n};","lang":"JavaScript"},{"s":"# @param {String} s\n# @param {String} p\n# @return {Boolean}\ndef is_match(s, p)\n \nend","lang":"Ruby"},{"s":"class Solution {\n    func isMatch(_ s: String, _ p: String) -> Bool {\n        \n    }\n}","lang":"Swift"},{"s":"func isMatch(s string, p string) bool {\n \n}","lang":"Go"},{"s":"object Solution {\n    def isMatch(s: String, p: String): Boolean = {\n \n    }\n}","lang":"Scala"},{"s":"class Solution {\n    fun isMatch(s: String, p: String): Boolean {\n \n    }\n}","lang":"Kotlin"},{"s":"impl Solution {\n    pub fn is_match(s: String, p: String) -> bool {\n        \n    }\n}","lang":"Rust"},{"s":"class Solution {\n \n    /**\n     * @param String $s\n     * @param String $p\n     * @return Boolean\n     */\n    function isMatch($s, $p) {\n        \n    }\n}","lang":"PHP"},{"s":"class Solution {\n \n    /**\n     * @param String $s\n     * @param String $p\n     * @return Boolean\n     */\n    function isMatch($s, $p) {\n        \n    }\n}","lang":"PHP"}],"page":"10/1581","h":"10. 正则表达式匹配","d":"<div class=\"notranslate\"><p>给你一个字符串&nbsp;<code>s</code>&nbsp;和一个字符规律&nbsp;<code>p</code>，请你来实现一个支持 <code>'.'</code>&nbsp;和&nbsp;<code>'*'</code>&nbsp;的正则表达式匹配。</p>\n\n<pre>'.' 匹配任意单个字符\n'*' 匹配零个或多个前面的那一个元素\n</pre>\n\n<p>所谓匹配，是要涵盖&nbsp;<strong>整个&nbsp;</strong>字符串&nbsp;<code>s</code>的，而不是部分字符串。</p>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li><code>s</code>&nbsp;可能为空，且只包含从&nbsp;<code>a-z</code>&nbsp;的小写字母。</li>\n\t<li><code>p</code>&nbsp;可能为空，且只包含从&nbsp;<code>a-z</code>&nbsp;的小写字母，以及字符&nbsp;<code>.</code>&nbsp;和&nbsp;<code>*</code>。</li>\n</ul>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong>\ns = \"aa\"\np = \"a\"\n<strong>输出:</strong> false\n<strong>解释:</strong> \"a\" 无法匹配 \"aa\" 整个字符串。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong>\ns = \"aa\"\np = \"a*\"\n<strong>输出:</strong> true\n<strong>解释:</strong>&nbsp;因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。\n</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre><strong>输入:</strong>\ns = \"ab\"\np = \".*\"\n<strong>输出:</strong> true\n<strong>解释:</strong>&nbsp;\".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。\n</pre>\n\n<p><strong>示例 4:</strong></p>\n\n<pre><strong>输入:</strong>\ns = \"aab\"\np = \"c*a*b\"\n<strong>输出:</strong> true\n<strong>解释:</strong>&nbsp;因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。\n</pre>\n\n<p><strong>示例 5:</strong></p>\n\n<pre><strong>输入:</strong>\ns = \"mississippi\"\np = \"mis*is*p*.\"\n<strong>输出:</strong> false</pre>\n</div>","l":"困难","s":"class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        \n    }\n};","lang":"C++","href":"https://leetcode-cn.com/problems/regular-expression-matching/","bb":{"x":490,"y":50,"w":116,"h":28}}

