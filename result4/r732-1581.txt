{"ls":[{"s":"class MyCalendarThree {\n \n    public MyCalendarThree() {\n \n    }\n    \n    public int book(int start, int end) {\n \n    }\n}\n \n/**\n * Your MyCalendarThree object will be instantiated \nand called as such:\n * MyCalendarThree obj = new MyCalendarThree();\n * int param_1 = obj.book(start,end);\n */","lang":"Java"},{"s":"class MyCalendarThree(object):\n \n    def __init__(self):\n        \n \n    def book(self, start, end):\n        \"\"\"\n        :type start: int\n        :type end: int\n        :rtype: int\n        \"\"\"\n        \n \n \n# Your MyCalendarThree object will be instantiated \nand called as such:\n# obj = MyCalendarThree()\n# param_1 = obj.book(start,end)","lang":"Python"},{"s":"class MyCalendarThree:\n \n    def __init__(self):\n        \n \n    def book(self, start: int, end: int) -> int:\n        \n \n \n# Your MyCalendarThree object will be instantiated \nand called as such:\n# obj = MyCalendarThree()\n# param_1 = obj.book(start,end)","lang":"Python3"},{"s":"typedef struct {\n    \n} MyCalendarThree;\n \n \nMyCalendarThree* myCalendarThreeCreate() {\n    \n}\n \nint myCalendarThreeBook(MyCalendarThree* obj, int \nstart, int end) {\n  \n}\n \nvoid myCalendarThreeFree(MyCalendarThree* obj) {\n    \n}\n \n/**\n * Your MyCalendarThree struct will be instantiated \nand called as such:\n * MyCalendarThree* obj = myCalendarThreeCreate();\n * int param_1 = myCalendarThreeBook(obj, start, \nend);\n \n * myCalendarThreeFree(obj);","lang":"C"},{"s":"public class MyCalendarThree {\n \n    public MyCalendarThree() {\n \n    }\n    \n    public int Book(int start, int end) {\n \n    }\n}\n \n/**\n * Your MyCalendarThree object will be instantiated \nand called as such:\n * MyCalendarThree obj = new MyCalendarThree();\n * int param_1 = obj.Book(start,end);\n */","lang":"C#"},{"s":"var MyCalendarThree = function() {\n \n};\n \n/** \n * @param {number} start \n * @param {number} end\n * @return {number}\n */\nMyCalendarThree.prototype.book = function(start, \nend) {\n \n};\n \n/**\n * Your MyCalendarThree object will be instantiated \nand called as such:\n * var obj = new MyCalendarThree()\n * var param_1 = obj.book(start,end)\n */","lang":"JavaScript"},{"s":"class MyCalendarThree\n    def initialize()\n \n    end\n \n \n=begin\n    :type start: Integer\n    :type end: Integer\n    :rtype: Integer\n=end\n    def book(start, end)\n \n    end\n \n \nend\n \n# Your MyCalendarThree object will be instantiated \nand called as such:\n# obj = MyCalendarThree.new()\n# param_1 = obj.book(start, end)","lang":"Ruby"},{"s":"class MyCalendarThree {\n \n    init() {\n        \n    }\n    \n    func book(_ start: Int, _ end: Int) -> Int {\n        \n    }\n}\n \n/**\n * Your MyCalendarThree object will be instantiated \nand called as such:\n * let obj = MyCalendarThree()\n * let ret_1: Int = obj.book(start, end)\n */","lang":"Swift"},{"s":"type MyCalendarThree struct {\n \n}\n \n \nfunc Constructor() MyCalendarThree {\n \n}\n \n \nfunc (this *MyCalendarThree) Book(start int, end \nint) int {\n \n}\n \n \n/**\n * Your MyCalendarThree object will be instantiated \nand called as such:\n * obj := Constructor();\n * param_1 := obj.Book(start,end);\n */","lang":"Go"},{"s":"class MyCalendarThree() {\n \n    def book(start: Int, end: Int): Int = {\n \n    }\n \n}\n \n/**\n * Your MyCalendarThree object will be instantiated \nand called as such:\n * var obj = new MyCalendarThree()\n * var param_1 = obj.book(start,end)\n */","lang":"Scala"},{"s":"class MyCalendarThree() {\n \n    fun book(start: Int, end: Int): Int {\n \n    }\n \n}\n \n/**\n * Your MyCalendarThree object will be instantiated \nand called as such:\n * var obj = MyCalendarThree()\n * var param_1 = obj.book(start,end)\n */","lang":"Kotlin"},{"s":"struct MyCalendarThree {\n \n}\n \n \n/** \n * `&self` means the method takes an immutable \nreference.\n * If you need a mutable reference, change it to `&\nmut self` instead.\n */\nimpl MyCalendarThree {\n \n    fn new() -> Self {\n        \n    }\n    \n    fn book(&self, start: i32, end: i32) -> i32 {\n        \n    }\n}\n \n/**\n * Your MyCalendarThree object will be instantiated \nand called as such:\n * let obj = MyCalendarThree::new();","lang":"Rust"},{"s":"class MyCalendarThree {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $start\n     * @param Integer $end\n     * @return Integer\n     */\n    function book($start, $end) {\n        \n    }\n}\n \n/**\n * Your MyCalendarThree object will be instantiated \nand called as such:\n * $obj = MyCalendarThree();\n * $ret_1 = $obj->book($start, $end);\n */","lang":"PHP"},{"s":"class MyCalendarThree {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $start\n     * @param Integer $end\n     * @return Integer\n     */\n    function book($start, $end) {\n        \n    }\n}\n \n/**\n * Your MyCalendarThree object will be instantiated \nand called as such:\n * $obj = MyCalendarThree();\n * $ret_1 = $obj->book($start, $end);\n */","lang":"PHP"}],"page":"732/1581","h":"732. 我的日程安排表 III","d":"<div class=\"notranslate\"><p>实现一个 <code>MyCalendar</code> 类来存放你的日程安排，你可以一直添加新的日程安排。</p>\n\n<p><code>MyCalendar</code> 有一个 <code>book(int start, int end)</code>方法。它意味着在start到end时间内增加一个日程安排，注意，这里的时间是半开区间，即 <code>[start, end)</code>, 实数&nbsp;<code>x</code> 的范围为， &nbsp;<code>start &lt;= x &lt; end</code>。</p>\n\n<p>当 <strong>K</strong> 个日程安排有一些时间上的交叉时（例如K个日程安排都在同一时间内），就会产生 <strong>K</strong> 次预订。</p>\n\n<p>每次调用 <code>MyCalendar.book</code>方法时，返回一个整数 <code>K</code> ，表示最大的 <code>K</code> 次预订。</p>\n\n<p>请按照以下步骤调用<code>MyCalendar</code> 类: <code>MyCalendar cal = new MyCalendar();</code> <code>MyCalendar.book(start, end)</code></p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>MyCalendarThree();\nMyCalendarThree.book(10, 20); // returns 1\nMyCalendarThree.book(50, 60); // returns 1\nMyCalendarThree.book(10, 40); // returns 2\nMyCalendarThree.book(5, 15); // returns 3\nMyCalendarThree.book(5, 10); // returns 3\nMyCalendarThree.book(25, 55); // returns 3\n<strong>解释:</strong> \n前两个日程安排可以预订并且不相交，所以最大的K次预订是1。\n第三个日程安排[10,40]与第一个日程安排相交，最高的K次预订为2。\n其余的日程安排的最高K次预订仅为3。\n请注意，最后一次日程安排可能会导致局部最高K次预订为2，但答案仍然是3，原因是从开始到最后，时间[10,20]，[10,40]和[5,15]仍然会导致3次预订。\n</pre>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li>每个测试用例，调用&nbsp;<code>MyCalendar.book</code>&nbsp;函数最多不超过&nbsp;<code>400</code>次。</li>\n\t<li>调用函数&nbsp;<code>MyCalendar.book(start, end)</code>时，&nbsp;<code>start</code> 和&nbsp;<code>end</code> 的取值范围为&nbsp;<code>[0, 10^9]</code>。</li>\n</ul>\n</div>","l":"困难","s":"class MyCalendarThree\n    def initialize()\n \n    end\n \n \n=begin\n    :type start: Integer\n    :type end: Integer\n    :rtype: Integer\n=end\n    def book(start, end)\n \n    end\n \n \nend\n \n# Your MyCalendarThree object will be instantiated \nand called as such:\n# obj = MyCalendarThree.new()\n# param_1 = obj.book(start, end)","lang":"Ruby","href":"https://leetcode-cn.com/problems/my-calendar-iii/","bb":{"x":445,"y":40,"w":116,"h":28}}

