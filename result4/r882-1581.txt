{"ls":[{"s":"# @param {Integer[][]} edges\n# @param {Integer} m\n# @param {Integer} n\n# @return {Integer}\ndef reachable_nodes(edges, m, n)\n \nend","lang":"Ruby"},{"s":"class Solution {\n    func reachableNodes(_ edges: [[Int]], _ M: Int, \n_ N: Int) -> Int {\n        \n    }\n}","lang":"Swift"},{"s":"func reachableNodes(edges [][]int, M int, N int) \nint {\n \n}","lang":"Go"},{"s":"object Solution {\n    def reachableNodes(edges: Array[Array[Int]], M: \nInt, N: Int): Int = {\n \n    }\n}","lang":"Scala"},{"s":"class Solution {\n    fun reachableNodes(edges: Array<IntArray>, M: \nInt, N: Int): Int {\n \n    }\n}","lang":"Kotlin"},{"s":"impl Solution {\n    pub fn reachable_nodes(edges: Vec<Vec<i32>>, m: \ni32, n: i32) -> i32 {\n        \n    }\n}","lang":"Rust"},{"s":"class Solution {\n    public int reachableNodes(int[][] edges, int M, \nint N) {\n \n    }\n}","lang":"Java"},{"s":"class Solution(object):\n    def reachableNodes(self, edges, M, N):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type M: int\n        :type N: int\n        :rtype: int\n        \"\"\"","lang":"Python"},{"s":"class Solution:\n    def reachableNodes(self, edges: List[List[int]],\n M: int, N: int) -> int:","lang":"Python3"},{"s":"int reachableNodes(int** edges, int edgesSize, int* \nedgesColSize, int M, int N){\n \n}","lang":"C"},{"s":"public class Solution {\n    public int ReachableNodes(int[][] edges, int M, \nint N) {\n \n    }\n}","lang":"C#"},{"s":"/**\n * @param {number[][]} edges\n * @param {number} M\n * @param {number} N\n * @return {number}\n */\nvar reachableNodes = function(edges, M, N) {\n \n};","lang":"JavaScript"},{"s":"# @param {Integer[][]} edges\n# @param {Integer} m\n# @param {Integer} n\n# @return {Integer}\ndef reachable_nodes(edges, m, n)\n \nend","lang":"Ruby"},{"s":"# @param {Integer[][]} edges\n# @param {Integer} m\n# @param {Integer} n\n# @return {Integer}\ndef reachable_nodes(edges, m, n)\n \nend","lang":"Ruby"}],"page":"882/1581","h":"882. 细分图中的可到达结点","d":"<div class=\"notranslate\"><p>从具有&nbsp;<code>0</code> 到 <code>N-1</code> 的结点的<strong>无向</strong>图（“原始图”）开始，对一些边进行细分。</p>\n\n<p>该图给出如下：<code>edges[k]</code>&nbsp;是整数对&nbsp;<code>(i, j, n)</code>&nbsp;组成的列表，使&nbsp;<code>(i, j)</code> 是原始图的边。</p>\n\n<p><code>n</code> 是该边上<strong>新</strong>结点的总数</p>\n\n<p>然后，将边&nbsp;<code>(i, j)</code>&nbsp;从原始图中删除，将&nbsp;<code>n</code>&nbsp;个新结点&nbsp;<code>(x_1, x_2, ..., x_n)</code>&nbsp;添加到原始图中，</p>\n\n<p>将&nbsp;<code>n+1</code>&nbsp;条新边&nbsp;<code>(i, x_1), (x_1, x_2), (x_2, x_3), ..., (x_{n-1}, x_n), (x_n, j)</code>&nbsp;添加到原始图中。</p>\n\n<p>现在，你将从原始图中的结点&nbsp;<code>0</code>&nbsp;处出发，并且每次移动，你都将沿着一条边行进。</p>\n\n<p>返回最多 <code>M</code> 次移动可以达到的结点数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong><code>edges </code>= [[0,1,10],[0,2,1],[1,2,2]], M = 6, N = 3\n<strong>输出：</strong>13\n<strong>解释：</strong>\n在 M = 6 次移动之后在最终图中可到达的结点如下所示。\n<img style=\"height: 200px; width: 487px;\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/01/origfinal.png\" alt=\"\">\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong><code>edges </code>= [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], M = 10, N = 4\n<strong>输出：</strong>23</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>0 &lt;= edges.length &lt;= 10000</code></li>\n\t<li><code>0 &lt;= edges[i][0] &lt;&nbsp;edges[i][1] &lt; N</code></li>\n\t<li>不存在任何&nbsp;<code>i != j</code>&nbsp;情况下&nbsp;<code>edges[i][0] == edges[j][0]</code>&nbsp;且&nbsp;<code>edges[i][1] == edges[j][1]</code>.</li>\n\t<li>原始图没有平行的边。</li>\n\t<li><code>0 &lt;= edges[i][2] &lt;= 10000</code></li>\n\t<li><code>0 &lt;= M &lt;= 10^9</code></li>\n\t<li><code>1 &lt;= N &lt;= 3000</code></li>\n\t<li>可到达结点是可以从结点 <code>0</code> 开始使用最多 <code>M</code> 次移动到达的结点。</li>\n</ol>\n\n<p>&nbsp;</p>\n</div>","l":"困难","s":"class Solution {","lang":"PHP","href":"https://leetcode-cn.com/problems/reachable-nodes-in-subdivided-graph/","bb":{"x":445,"y":40,"w":116,"h":28}}

