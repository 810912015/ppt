{"ls":[{"s":"# @param {Integer[][]} graph\n# @return {Integer[][]}\ndef all_paths_source_target(graph)\n \nend","lang":"Ruby"},{"s":"class Solution {\n    func allPathsSourceTarget(_ graph: [[Int]]) -> [\n[Int]] {\n        \n    }\n}","lang":"Swift"},{"s":"func allPathsSourceTarget(graph [][]int) [][]int {\n \n}","lang":"Go"},{"s":"object Solution {\n    def allPathsSourceTarget(graph: Array[Array[Int]\n]): List[List[Int]] = {\n \n    }\n}","lang":"Scala"},{"s":"class Solution {\n    fun allPathsSourceTarget(graph: Array<IntArray>)\n: List<List<Int>> {\n \n    }\n}","lang":"Kotlin"},{"s":"impl Solution {\n    pub fn all_paths_source_target(graph: \nVec<Vec<i32>>) -> Vec<Vec<i32>> {\n        \n    }\n}","lang":"Rust"},{"s":"class Solution {\n    public List<List<Integer>> allPathsSourceTarget\n(int[][] graph) {\n \n    }\n}","lang":"Java"},{"s":"class Solution(object):\n    def allPathsSourceTarget(self, graph):\n        \"\"\"\n        :type graph: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"","lang":"Python"},{"s":"class Solution:\n    def allPathsSourceTarget(self, graph: List[List\n[int]]) -> List[List[int]]:","lang":"Python3"},{"s":"/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as \n*returnColumnSizes array.\n * Note: Both returned array and *columnSizes array \nmust be malloced, assume caller calls free().\n */\nint** allPathsSourceTarget(int** graph, int \ngraphSize, int* graphColSize, int* returnSize, \nint** returnColumnSizes){\n \n}","lang":"C"},{"s":"public class Solution {\n    public IList<IList<int>> AllPathsSourceTarget\n(int[][] graph) {\n \n    }\n}","lang":"C#"},{"s":"/**\n * @param {number[][]} graph\n * @return {number[][]}\n */\nvar allPathsSourceTarget = function(graph) {\n \n};","lang":"JavaScript"},{"s":"# @param {Integer[][]} graph\n# @return {Integer[][]}\ndef all_paths_source_target(graph)\n \nend","lang":"Ruby"},{"s":"# @param {Integer[][]} graph\n# @return {Integer[][]}\ndef all_paths_source_target(graph)\n \nend","lang":"Ruby"}],"page":"797/1581","h":"797. 所有可能的路径","d":"<div class=\"notranslate\"><p>给一个有&nbsp;<code>n</code>&nbsp;个结点的有向无环图，找到所有从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n-1</code>&nbsp;的路径并输出（不要求按顺序）</p>\n\n<p>二维数组的第 i 个数组中的单元都表示有向图中 i 号结点所能到达的下一些结点（译者注：有向图是有方向的，即规定了a→b你就不能从b→a）空就是没有下一个结点了。</p>\n\n<pre><strong>示例:</strong>\n<strong>输入:</strong> [[1,2], [3], [3], []] \n<strong>输出:</strong> [[0,1,3],[0,2,3]] \n<strong>解释:</strong> 图是这样的:\n0---&gt;1\n|    |\nv    v\n2---&gt;3\n这有两条路: 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3.\n</pre>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>结点的数量会在范围&nbsp;<code>[2, 15]</code>&nbsp;内。</li>\n\t<li>你可以把路径以任意顺序输出，但在路径内的结点的顺序必须保证。</li>\n</ul>\n</div>","l":"中等","s":"class Solution {\n \n    /**\n     * @param Integer[][] $graph\n     * @return Integer[][]\n     */\n    function allPathsSourceTarget($graph) {\n        \n    }\n}","lang":"PHP","href":"https://leetcode-cn.com/problems/all-paths-from-source-to-target/","bb":{"x":445,"y":40,"w":116,"h":28}}

