{"ls":[{"s":"class Solution\n \n=begin\n    :type rects: Integer[][]\n=end\n    def initialize(rects)\n \n    end\n \n \n=begin\n    :rtype: Integer[]\n=end\n    def pick()\n \n    end\n \n \nend\n \n# Your Solution object will be instantiated and \ncalled as such:\n# obj = Solution.new(rects)\n# param_1 = obj.pick()","lang":"Ruby"},{"s":"class Solution {\n \n    init(_ rects: [[Int]]) {\n        \n    }\n    \n    func pick() -> [Int] {\n        \n    }\n}\n \n/**\n * Your Solution object will be instantiated and \ncalled as such:\n * let obj = Solution(rects)\n * let ret_1: [Int] = obj.pick()\n */","lang":"Swift"},{"s":"type Solution struct {\n \n}\n \n \nfunc Constructor(rects [][]int) Solution {\n \n}\n \n \nfunc (this *Solution) Pick() []int {\n \n}\n \n \n/**\n * Your Solution object will be instantiated and \ncalled as such:\n * obj := Constructor(rects);\n * param_1 := obj.Pick();\n */","lang":"Go"},{"s":"class Solution(_rects: Array[Array[Int]]) {\n \n    def pick(): Array[Int] = {\n \n    }\n \n}\n \n/**\n * Your Solution object will be instantiated and \ncalled as such:\n * var obj = new Solution(rects)\n * var param_1 = obj.pick()\n */","lang":"Scala"},{"s":"class Solution(rects: Array<IntArray>) {\n \n    fun pick(): IntArray {\n \n    }\n \n}\n \n/**\n * Your Solution object will be instantiated and \ncalled as such:\n * var obj = Solution(rects)\n * var param_1 = obj.pick()\n */","lang":"Kotlin"},{"s":"struct Solution {\n \n}\n \n \n/** \n * `&self` means the method takes an immutable \nreference.\n * If you need a mutable reference, change it to `&\nmut self` instead.\n */\nimpl Solution {\n \n    fn new(rects: Vec<Vec<i32>>) -> Self {\n        \n    }\n    \n    fn pick(&self) -> Vec<i32> {\n        \n    }\n}\n \n/**\n * Your Solution object will be instantiated and \ncalled as such:\n * let obj = Solution::new(rects);","lang":"Rust"},{"s":"class Solution {\n \n    public Solution(int[][] rects) {\n \n    }\n    \n    public int[] pick() {\n \n    }\n}\n \n/**\n * Your Solution object will be instantiated and \ncalled as such:\n * Solution obj = new Solution(rects);\n * int[] param_1 = obj.pick();\n */","lang":"Java"},{"s":"class Solution(object):\n \n    def __init__(self, rects):\n        \"\"\"\n        :type rects: List[List[int]]\n        \"\"\"\n        \n \n    def pick(self):\n        \"\"\"\n        :rtype: List[int]\n        \"\"\"\n        \n \n \n# Your Solution object will be instantiated and \ncalled as such:\n# obj = Solution(rects)\n# param_1 = obj.pick()","lang":"Python"},{"s":"class Solution:\n \n    def __init__(self, rects: List[List[int]]):\n        \n \n    def pick(self) -> List[int]:\n        \n \n \n# Your Solution object will be instantiated and \ncalled as such:\n# obj = Solution(rects)\n# param_1 = obj.pick()","lang":"Python3"},{"s":"typedef struct {\n    \n} Solution;\n \n \nSolution* solutionCreate(int** rects, int rectsSize,\n int* rectsColSize) {\n    \n}\n \nint* solutionPick(Solution* obj, int* retSize) {\n  \n}\n \nvoid solutionFree(Solution* obj) {\n    \n}\n \n/**\n * Your Solution struct will be instantiated and \ncalled as such:\n * Solution* obj = solutionCreate(rects, rectsSize, \nrectsColSize);\n * int* param_1 = solutionPick(obj, retSize);\n \n * solutionFree(obj);","lang":"C"},{"s":"public class Solution {\n \n    public Solution(int[][] rects) {\n \n    }\n    \n    public int[] Pick() {\n \n    }\n}\n \n/**\n * Your Solution object will be instantiated and \ncalled as such:\n * Solution obj = new Solution(rects);\n * int[] param_1 = obj.Pick();\n */","lang":"C#"},{"s":"/**\n * @param {number[][]} rects\n */\nvar Solution = function(rects) {\n \n};\n \n/**\n * @return {number[]}\n */\nSolution.prototype.pick = function() {\n \n};\n \n/**\n * Your Solution object will be instantiated and \ncalled as such:\n * var obj = new Solution(rects)\n * var param_1 = obj.pick()\n */","lang":"JavaScript"},{"s":"class Solution\n \n=begin\n    :type rects: Integer[][]\n=end\n    def initialize(rects)\n \n    end\n \n \n=begin\n    :rtype: Integer[]\n=end\n    def pick()\n \n    end\n \n \nend\n \n# Your Solution object will be instantiated and \ncalled as such:\n# obj = Solution.new(rects)\n# param_1 = obj.pick()","lang":"Ruby"},{"s":"class Solution\n \n=begin\n    :type rects: Integer[][]\n=end\n    def initialize(rects)\n \n    end\n \n \n=begin\n    :rtype: Integer[]\n=end\n    def pick()\n \n    end\n \n \nend\n \n# Your Solution object will be instantiated and \ncalled as such:\n# obj = Solution.new(rects)\n# param_1 = obj.pick()","lang":"Ruby"}],"page":"497/1581","h":"497. 非重叠矩形中的随机点","d":"<div class=\"notranslate\"><p>给定一个非重叠轴对齐矩形的列表 <code>rects</code>，写一个函数 <code>pick</code> 随机均匀地选取矩形覆盖的空间中的整数点。</p>\n\n<p>提示：</p>\n\n<ol>\n\t<li><strong>整数点</strong>是具有整数坐标的点。</li>\n\t<li>矩形周边上的点包含在矩形覆盖的空间中。</li>\n\t<li>第 <code>i</code> 个矩形 <code>rects [i] = [x1，y1，x2，y2]</code>，其中&nbsp;<code>[x1，y1]</code> 是左下角的整数坐标，<code>[x2，y2]</code> 是右上角的整数坐标。</li>\n\t<li>每个矩形的长度和宽度不超过 2000。</li>\n\t<li><code>1 &lt;= rects.length&nbsp;&lt;= 100</code></li>\n\t<li><code>pick</code> 以整数坐标数组&nbsp;<code>[p_x, p_y]</code>&nbsp;的形式返回一个点。</li>\n\t<li><code>pick</code> 最多被调用10000次。</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入: \n</strong>[\"Solution\",\"pick\",\"pick\",\"pick\"]\n[[[[1,1,5,5]]],[],[],[]]\n<strong>输出: \n</strong>[null,[4,1],[4,1],[3,3]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入: \n</strong>[\"Solution\",\"pick\",\"pick\",\"pick\",\"pick\",\"pick\"]\n[[[[-2,-2,-1,-1],[1,0,3,0]]],[],[],[],[],[]]\n<strong>输出: \n</strong>[null,[-1,-2],[2,0],[-2,-1],[3,0],[-2,-2]]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>输入语法的说明：</strong></p>\n\n<p>输入是两个列表：调用的子例程及其参数。<code>Solution</code> 的构造函数有一个参数，即矩形数组 <code>rects</code>。<code>pick</code> 没有参数。参数总是用列表包装的，即使没有也是如此。</p>\n\n<p>&nbsp;</p>\n</div>","l":"中等","s":"","lang":"PHP","href":"https://leetcode-cn.com/problems/random-point-in-non-overlapping-rectangles/","bb":{"x":445,"y":40,"w":116,"h":28}}

