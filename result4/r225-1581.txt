{"ls":[{"s":"class MyStack {\n \n    /** Initialize your data structure here. */\n    public MyStack() {\n \n    }\n    \n    /** Push element x onto stack. */\n    public void push(int x) {\n \n    }\n    \n    /** Removes the element on top of the stack and \nreturns that element. */\n    public int pop() {\n \n    }\n    \n    /** Get the top element. */\n    public int top() {\n \n    }\n    \n    /** Returns whether the stack is empty. */\n    public boolean empty() {\n ","lang":"Java"},{"s":"class MyStack(object):\n \n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n \n \n    def push(self, x):\n        \"\"\"\n        Push element x onto stack.\n        :type x: int\n        :rtype: None\n        \"\"\"\n \n \n    def pop(self):\n        \"\"\"\n        Removes the element on top of the stack and \nreturns that element.\n        :rtype: int\n        \"\"\"\n \n \n    def top(self):\n        \"\"\"","lang":"Python"},{"s":"class MyStack:\n \n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n \n \n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x onto stack.\n        \"\"\"\n \n \n    def pop(self) -> int:\n        \"\"\"\n        Removes the element on top of the stack and \nreturns that element.\n        \"\"\"\n \n \n    def top(self) -> int:\n        \"\"\"\n        Get the top element.\n        \"\"\"\n ","lang":"Python3"},{"s":"typedef struct {\n \n} MyStack;\n \n/** Initialize your data structure here. */\n \nMyStack* myStackCreate() {\n \n}\n \n/** Push element x onto stack. */\nvoid myStackPush(MyStack* obj, int x) {\n \n}\n \n/** Removes the element on top of the stack and \nreturns that element. */\nint myStackPop(MyStack* obj) {\n \n}\n \n/** Get the top element. */\nint myStackTop(MyStack* obj) {\n \n}\n ","lang":"C"},{"s":"public class MyStack {\n \n    /** Initialize your data structure here. */\n    public MyStack() {\n \n    }\n    \n    /** Push element x onto stack. */\n    public void Push(int x) {\n \n    }\n    \n    /** Removes the element on top of the stack and \nreturns that element. */\n    public int Pop() {\n \n    }\n    \n    /** Get the top element. */\n    public int Top() {\n \n    }\n    \n    /** Returns whether the stack is empty. */\n    public bool Empty() {\n ","lang":"C#"},{"s":"/**\n * Initialize your data structure here.\n */\nvar MyStack = function() {\n \n};\n \n/**\n * Push element x onto stack. \n * @param {number} x\n * @return {void}\n */\nMyStack.prototype.push = function(x) {\n \n};\n \n/**\n * Removes the element on top of the stack and \nreturns that element.\n * @return {number}\n */\nMyStack.prototype.pop = function() {\n \n};\n \n/**","lang":"JavaScript"},{"s":"class MyStack\n \n=begin\n    Initialize your data structure here.\n=end\n    def initialize()\n \n    end\n \n \n=begin\n    Push element x onto stack.\n    :type x: Integer\n    :rtype: Void\n=end\n    def push(x)\n \n    end\n \n \n=begin\n    Removes the element on top of the stack and \nreturns that element.\n    :rtype: Integer\n=end\n    def pop()","lang":"Ruby"},{"s":"class MyStack {\n \n    /** Initialize your data structure here. */\n    init() {\n \n    }\n    \n    /** Push element x onto stack. */\n    func push(_ x: Int) {\n \n    }\n    \n    /** Removes the element on top of the stack and \nreturns that element. */\n    func pop() -> Int {\n \n    }\n    \n    /** Get the top element. */\n    func top() -> Int {\n \n    }\n    \n    /** Returns whether the stack is empty. */\n    func empty() -> Bool {\n ","lang":"Swift"},{"s":"type MyStack struct {\n \n}\n \n \n/** Initialize your data structure here. */\nfunc Constructor() MyStack {\n \n}\n \n \n/** Push element x onto stack. */\nfunc (this *MyStack) Push(x int)  {\n \n}\n \n \n/** Removes the element on top of the stack and \nreturns that element. */\nfunc (this *MyStack) Pop() int {\n \n}\n \n \n/** Get the top element. */\nfunc (this *MyStack) Top() int {","lang":"Go"},{"s":"class MyStack() {\n \n    /** Initialize your data structure here. */\n \n \n    /** Push element x onto stack. */\n    def push(x: Int) {\n \n    }\n \n    /** Removes the element on top of the stack and \nreturns that element. */\n    def pop(): Int = {\n \n    }\n \n    /** Get the top element. */\n    def top(): Int = {\n \n    }\n \n    /** Returns whether the stack is empty. */\n    def empty(): Boolean = {\n \n    }\n ","lang":"Scala"},{"s":"class MyStack() {\n \n    /** Initialize your data structure here. */\n \n \n    /** Push element x onto stack. */\n    fun push(x: Int) {\n \n    }\n \n    /** Removes the element on top of the stack and \nreturns that element. */\n    fun pop(): Int {\n \n    }\n \n    /** Get the top element. */\n    fun top(): Int {\n \n    }\n \n    /** Returns whether the stack is empty. */\n    fun empty(): Boolean {\n \n    }\n ","lang":"Kotlin"},{"s":"struct MyStack {\n \n}\n \n \n/**\n * `&self` means the method takes an immutable \nreference.\n * If you need a mutable reference, change it to `&\nmut self` instead.\n */\nimpl MyStack {\n \n    /** Initialize your data structure here. */\n    fn new() -> Self {\n \n    }\n    \n    /** Push element x onto stack. */\n    fn push(&self, x: i32) {\n \n    }\n    \n    /** Removes the element on top of the stack and \nreturns that element. */\n    fn pop(&self) -> i32 {","lang":"Rust"},{"s":"class MyStack {\n    /**\n     * Initialize your data structure here.\n     */\n    function __construct() {\n \n    }\n \n    /**\n     * Push element x onto stack.\n     * @param Integer $x\n     * @return NULL\n     */\n    function push($x) {\n \n    }\n \n    /**\n     * Removes the element on top of the stack and \nreturns that element.\n     * @return Integer\n     */\n    function pop() {\n \n    }\n ","lang":"PHP"},{"s":"class MyStack {\n    /**\n     * Initialize your data structure here.\n     */\n    function __construct() {\n \n    }\n \n    /**\n     * Push element x onto stack.\n     * @param Integer $x\n     * @return NULL\n     */\n    function push($x) {\n \n    }\n \n    /**\n     * Removes the element on top of the stack and \nreturns that element.\n     * @return Integer\n     */\n    function pop() {\n \n    }\n ","lang":"PHP"}],"page":"225/1581","h":"225. 用队列实现栈","d":"<div class=\"notranslate\"><p>使用队列实现栈的下列操作：</p>\n\n<ul>\n\t<li>push(x) -- 元素 x 入栈</li>\n\t<li>pop() -- 移除栈顶元素</li>\n\t<li>top() -- 获取栈顶元素</li>\n\t<li>empty() -- 返回栈是否为空</li>\n</ul>\n\n<p><strong>注意:</strong></p>\n\n<ul>\n\t<li>你只能使用队列的基本操作-- 也就是&nbsp;<code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, 和&nbsp;<code>is empty</code>&nbsp;这些操作是合法的。</li>\n\t<li>你所使用的语言也许不支持队列。&nbsp;你可以使用 list 或者 deque（双端队列）来模拟一个队列&nbsp;, 只要是标准的队列操作即可。</li>\n\t<li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li>\n</ul>\n</div>","l":"简单","s":"class MyStack","lang":"Ruby","href":"https://leetcode-cn.com/problems/implement-stack-using-queues/","bb":{"x":445,"y":40,"w":116,"h":28}}

