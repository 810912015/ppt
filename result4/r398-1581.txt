{"ls":[{"s":"class Solution\n \n=begin\n    :type nums: Integer[]\n=end\n    def initialize(nums)\n \n    end\n \n \n=begin\n    :type target: Integer\n    :rtype: Integer\n=end\n    def pick(target)\n \n    end\n \n \nend\n \n# Your Solution object will be instantiated and \ncalled as such:\n# obj = Solution.new(nums)\n# param_1 = obj.pick(target)","lang":"Ruby"},{"s":"class Solution {\n \n    init(_ nums: [Int]) {\n        \n    }\n    \n    func pick(_ target: Int) -> Int {\n        \n    }\n}\n \n/**\n * Your Solution object will be instantiated and \ncalled as such:\n * let obj = Solution(nums)\n * let ret_1: Int = obj.pick(target)\n */","lang":"Swift"},{"s":"type Solution struct {\n \n}\n \n \nfunc Constructor(nums []int) Solution {\n \n}\n \n \nfunc (this *Solution) Pick(target int) int {\n \n}\n \n \n/**\n * Your Solution object will be instantiated and \ncalled as such:\n * obj := Constructor(nums);\n * param_1 := obj.Pick(target);\n */","lang":"Go"},{"s":"class Solution(_nums: Array[Int]) {\n \n    def pick(target: Int): Int = {\n \n    }\n \n}\n \n/**\n * Your Solution object will be instantiated and \ncalled as such:\n * var obj = new Solution(nums)\n * var param_1 = obj.pick(target)\n */","lang":"Scala"},{"s":"class Solution(nums: IntArray) {\n \n    fun pick(target: Int): Int {\n \n    }\n \n}\n \n/**\n * Your Solution object will be instantiated and \ncalled as such:\n * var obj = Solution(nums)\n * var param_1 = obj.pick(target)\n */","lang":"Kotlin"},{"s":"struct Solution {\n \n}\n \n \n/** \n * `&self` means the method takes an immutable \nreference.\n * If you need a mutable reference, change it to `&\nmut self` instead.\n */\nimpl Solution {\n \n    fn new(nums: Vec<i32>) -> Self {\n        \n    }\n    \n    fn pick(&self, target: i32) -> i32 {\n        \n    }\n}\n \n/**\n * Your Solution object will be instantiated and \ncalled as such:\n * let obj = Solution::new(nums);","lang":"Rust"},{"s":"class Solution {\n \n    public Solution(int[] nums) {\n \n    }\n    \n    public int pick(int target) {\n \n    }\n}\n \n/**\n * Your Solution object will be instantiated and \ncalled as such:\n * Solution obj = new Solution(nums);\n * int param_1 = obj.pick(target);\n */","lang":"Java"},{"s":"class Solution(object):\n \n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        \n \n    def pick(self, target):\n        \"\"\"\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n \n \n# Your Solution object will be instantiated and \ncalled as such:\n# obj = Solution(nums)\n# param_1 = obj.pick(target)","lang":"Python"},{"s":"class Solution:\n \n    def __init__(self, nums: List[int]):\n        \n \n    def pick(self, target: int) -> int:\n        \n \n \n# Your Solution object will be instantiated and \ncalled as such:\n# obj = Solution(nums)\n# param_1 = obj.pick(target)","lang":"Python3"},{"s":"typedef struct {\n    \n} Solution;\n \n \nSolution* solutionCreate(int* nums, int numsSize) {\n    \n}\n \nint solutionPick(Solution* obj, int target) {\n  \n}\n \nvoid solutionFree(Solution* obj) {\n    \n}\n \n/**\n * Your Solution struct will be instantiated and \ncalled as such:\n * Solution* obj = solutionCreate(nums, numsSize);\n * int param_1 = solutionPick(obj, target);\n \n * solutionFree(obj);\n*/","lang":"C"},{"s":"public class Solution {\n \n    public Solution(int[] nums) {\n \n    }\n    \n    public int Pick(int target) {\n \n    }\n}\n \n/**\n * Your Solution object will be instantiated and \ncalled as such:\n * Solution obj = new Solution(nums);\n * int param_1 = obj.Pick(target);\n */","lang":"C#"},{"s":"/**\n * @param {number[]} nums\n */\nvar Solution = function(nums) {\n \n};\n \n/** \n * @param {number} target\n * @return {number}\n */\nSolution.prototype.pick = function(target) {\n \n};\n \n/**\n * Your Solution object will be instantiated and \ncalled as such:\n * var obj = new Solution(nums)\n * var param_1 = obj.pick(target)\n */","lang":"JavaScript"},{"s":"class Solution\n \n=begin\n    :type nums: Integer[]\n=end\n    def initialize(nums)\n \n    end\n \n \n=begin\n    :type target: Integer\n    :rtype: Integer\n=end\n    def pick(target)\n \n    end\n \n \nend\n \n# Your Solution object will be instantiated and \ncalled as such:\n# obj = Solution.new(nums)\n# param_1 = obj.pick(target)","lang":"Ruby"},{"s":"class Solution\n \n=begin\n    :type nums: Integer[]\n=end\n    def initialize(nums)\n \n    end\n \n \n=begin\n    :type target: Integer\n    :rtype: Integer\n=end\n    def pick(target)\n \n    end\n \n \nend\n \n# Your Solution object will be instantiated and \ncalled as such:\n# obj = Solution.new(nums)\n# param_1 = obj.pick(target)","lang":"Ruby"}],"page":"398/1581","h":"398. 随机数索引","d":"<div class=\"notranslate\"><p>给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的索引。 您可以假设给定的数字一定存在于数组中。</p>\n\n<p><strong>注意：</strong><br>\n数组大小可能非常大。 使用太多额外空间的解决方案将不会通过测试。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre>int[] nums = new int[] {1,2,3,3,3};\nSolution solution = new Solution(nums);\n\n// pick(3) 应该返回索引 2,3 或者 4。每个索引的返回概率应该相等。\nsolution.pick(3);\n\n// pick(1) 应该返回 0。因为只有nums[0]等于1。\nsolution.pick(1);\n</pre>\n</div>","l":"中等","s":"class Solution {","lang":"PHP","href":"https://leetcode-cn.com/problems/random-pick-index/","bb":{"x":445,"y":40,"w":116,"h":28}}

