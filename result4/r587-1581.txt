{"ls":[{"s":"# @param {Integer[][]} points\n# @return {Integer[][]}\ndef outer_trees(points)\n \nend","lang":"Ruby"},{"s":"class Solution {\n    func outerTrees(_ points: [[Int]]) -> [[Int]] {\n        \n    }\n}","lang":"Swift"},{"s":"func outerTrees(points [][]int) [][]int {\n \n}","lang":"Go"},{"s":"object Solution {\n    def outerTrees(points: Array[Array[Int]]): Array\n[Array[Int]] = {\n \n    }\n}","lang":"Scala"},{"s":"class Solution {\n    fun outerTrees(points: Array<IntArray>): \nArray<IntArray> {\n \n    }\n}","lang":"Kotlin"},{"s":"impl Solution {\n    pub fn outer_trees(points: Vec<Vec<i32>>) -> \nVec<Vec<i32>> {\n        \n    }\n}","lang":"Rust"},{"s":"class Solution {\n    public int[][] outerTrees(int[][] points) {\n \n    }\n}","lang":"Java"},{"s":"class Solution(object):\n    def outerTrees(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"","lang":"Python"},{"s":"class Solution:\n    def outerTrees(self, points: List[List[int]]) \n-> List[List[int]]:","lang":"Python3"},{"s":"/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as \n*returnColumnSizes array.\n * Note: Both returned array and *columnSizes array \nmust be malloced, assume caller calls free().\n */\nint** outerTrees(int** points, int pointsSize, int* \npointsColSize, int* returnSize, int** \nreturnColumnSizes){\n \n}","lang":"C"},{"s":"public class Solution {\n    public int[][] OuterTrees(int[][] points) {\n \n    }\n}","lang":"C#"},{"s":"/**\n * @param {number[][]} points\n * @return {number[][]}\n */\nvar outerTrees = function(points) {\n \n};","lang":"JavaScript"},{"s":"# @param {Integer[][]} points\n# @return {Integer[][]}\ndef outer_trees(points)\n \nend","lang":"Ruby"},{"s":"# @param {Integer[][]} points\n# @return {Integer[][]}\ndef outer_trees(points)\n \nend","lang":"Ruby"}],"page":"587/1581","h":"587. 安装栅栏","d":"<div class=\"notranslate\"><p>在一个二维的花园中，有一些用 (x, y) 坐标表示的树。由于安装费用十分昂贵，你的任务是先用<strong>最短</strong>的绳子围起所有的树。只有当所有的树都被绳子包围时，花园才能围好栅栏。你需要找到正好位于栅栏边界上的树的坐标。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]\n<strong>输出:</strong> [[1,1],[2,0],[4,2],[3,3],[2,4]]\n<strong>解释:</strong>\n<img style=\"width: 100%; max-width: 320px\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/erect_the_fence_1.png\">\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> [[1,2],[2,2],[4,2]]\n<strong>输出:</strong> [[1,2],[2,2],[4,2]]\n<strong>解释:</strong>\n<img style=\"width: 100%; max-width: 320px\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/erect_the_fence_2.png\">\n即使树都在一条直线上，你也需要先用绳子包围它们。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>注意:</strong></p>\n\n<ol>\n\t<li>所有的树应当被围在一起。你不能剪断绳子来包围树或者把树分成一组以上。</li>\n\t<li>输入的整数在 0 到 100 之间。</li>\n\t<li>花园至少有一棵树。</li>\n\t<li>所有树的坐标都是不同的。</li>\n\t<li>输入的点<strong>没有</strong>顺序。输出顺序也没有要求。</li>\n</ol></div>","l":"困难","s":"class Solution {\n \n    /**\n     * @param Integer[][] $points\n     * @return Integer[][]\n     */\n    function outerTrees($points) {\n        \n    }\n}","lang":"PHP","href":"https://leetcode-cn.com/problems/erect-the-fence/","bb":{"x":445,"y":40,"w":116,"h":28}}

