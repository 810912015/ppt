{"ls":[{"s":"# @param {Integer[][]} nums\n# @return {Integer[]}\ndef smallest_range(nums)\n \nend","lang":"Ruby"},{"s":"class Solution {\n    func smallestRange(_ nums: [[Int]]) -> [Int] {\n        \n    }\n}","lang":"Swift"},{"s":"func smallestRange(nums [][]int) []int {\n \n}","lang":"Go"},{"s":"object Solution {\n    def smallestRange(nums: List[List[Int]]): Array\n[Int] = {\n \n    }\n}","lang":"Scala"},{"s":"class Solution {\n    fun smallestRange(nums: List<List<Int>>): \nIntArray {\n \n    }\n}","lang":"Kotlin"},{"s":"impl Solution {\n    pub fn smallest_range(nums: Vec<Vec<i32>>) -> \nVec<i32> {\n        \n    }\n}","lang":"Rust"},{"s":"class Solution {\n    public int[] smallestRange(List<List<Integer>> \nnums) {\n \n    }\n}","lang":"Java"},{"s":"class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"","lang":"Python"},{"s":"class Solution:\n    def smallestRange(self, nums: List[List[int]]) \n-> List[int]:","lang":"Python3"},{"s":"/**\n * Note: The returned array must be malloced, \nassume caller calls free().\n */\nint* smallestRange(int** nums, int numsSize, int* \nnumsColSize, int* returnSize){\n \n}","lang":"C"},{"s":"public class Solution {\n    public int[] SmallestRange(IList<IList<int>> \nnums) {\n \n    }\n}","lang":"C#"},{"s":"/**\n * @param {number[][]} nums\n * @return {number[]}\n */\nvar smallestRange = function(nums) {\n \n};","lang":"JavaScript"},{"s":"# @param {Integer[][]} nums\n# @return {Integer[]}\ndef smallest_range(nums)\n \nend","lang":"Ruby"},{"s":"# @param {Integer[][]} nums\n# @return {Integer[]}\ndef smallest_range(nums)\n \nend","lang":"Ruby"}],"page":"632/1581","h":"632. 最小区间","d":"<div class=\"notranslate\"><p>你有&nbsp;<code>k</code>&nbsp;个升序排列的整数数组。找到一个<strong>最小</strong>区间，使得&nbsp;<code>k</code>&nbsp;个列表中的每个列表至少有一个数包含在其中。</p>\n\n<p>我们定义如果&nbsp;<code>b-a &lt; d-c</code>&nbsp;或者在&nbsp;<code>b-a == d-c</code>&nbsp;时&nbsp;<code>a &lt; c</code>，则区间 [a,b] 比 [c,d] 小。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong>[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]\n<strong>输出:</strong> [20,24]\n<strong>解释:</strong> \n列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。\n列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。\n列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。\n</pre>\n\n<p><strong>注意:</strong></p>\n\n<ol>\n\t<li>给定的列表可能包含重复元素，所以在这里升序表示 &gt;= 。</li>\n\t<li>1 &lt;= <code>k</code> &lt;= 3500</li>\n\t<li>-10<sup>5</sup> &lt;= <code>元素的值</code>&nbsp;&lt;= 10<sup>5</sup></li>\n\t<li><strong>对于使用Java的用户，请注意传入类型已修改为List&lt;List&lt;Integer&gt;&gt;。重置代码模板后可以看到这项改动。</strong></li>\n</ol>\n</div>","l":"困难","s":"class Solution {","lang":"PHP","href":"https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/","bb":{"x":445,"y":40,"w":116,"h":28}}

