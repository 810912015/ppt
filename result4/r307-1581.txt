{"ls":[{"s":"class NumArray {\n \n    public NumArray(int[] nums) {\n \n    }\n    \n    public void update(int i, int val) {\n \n    }\n    \n    public int sumRange(int i, int j) {\n \n    }\n}\n \n/**\n * Your NumArray object will be instantiated and \ncalled as such:\n * NumArray obj = new NumArray(nums);\n * obj.update(i,val);\n * int param_2 = obj.sumRange(i,j);\n */","lang":"Java"},{"s":"class NumArray(object):\n \n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        \n \n    def update(self, i, val):\n        \"\"\"\n        :type i: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        \n \n    def sumRange(self, i, j):\n        \"\"\"\n        :type i: int\n        :type j: int\n        :rtype: int\n        \"\"\"\n        \n \n \n# Your NumArray object will be instantiated and ","lang":"Python"},{"s":"class NumArray:\n \n    def __init__(self, nums: List[int]):\n        \n \n    def update(self, i: int, val: int) -> None:\n        \n \n    def sumRange(self, i: int, j: int) -> int:\n        \n \n \n# Your NumArray object will be instantiated and \ncalled as such:\n# obj = NumArray(nums)\n# obj.update(i,val)\n# param_2 = obj.sumRange(i,j)","lang":"Python3"},{"s":"typedef struct {\n    \n} NumArray;\n \n \nNumArray* numArrayCreate(int* nums, int numsSize) {\n    \n}\n \nvoid numArrayUpdate(NumArray* obj, int i, int val) {\n  \n}\n \nint numArraySumRange(NumArray* obj, int i, int j) {\n  \n}\n \nvoid numArrayFree(NumArray* obj) {\n    \n}\n \n/**\n * Your NumArray struct will be instantiated and \ncalled as such:\n * NumArray* obj = numArrayCreate(nums, numsSize);\n * numArrayUpdate(obj, i, val);","lang":"C"},{"s":"public class NumArray {\n \n    public NumArray(int[] nums) {\n \n    }\n    \n    public void Update(int i, int val) {\n \n    }\n    \n    public int SumRange(int i, int j) {\n \n    }\n}\n \n/**\n * Your NumArray object will be instantiated and \ncalled as such:\n * NumArray obj = new NumArray(nums);\n * obj.Update(i,val);\n * int param_2 = obj.SumRange(i,j);\n */","lang":"C#"},{"s":"/**\n * @param {number[]} nums\n */\nvar NumArray = function(nums) {\n \n};\n \n/** \n * @param {number} i \n * @param {number} val\n * @return {void}\n */\nNumArray.prototype.update = function(i, val) {\n \n};\n \n/** \n * @param {number} i \n * @param {number} j\n * @return {number}\n */\nNumArray.prototype.sumRange = function(i, j) {\n \n};\n \n/**","lang":"JavaScript"},{"s":"class NumArray\n \n=begin\n    :type nums: Integer[]\n=end\n    def initialize(nums)\n \n    end\n \n \n=begin\n    :type i: Integer\n    :type val: Integer\n    :rtype: Void\n=end\n    def update(i, val)\n \n    end\n \n \n=begin\n    :type i: Integer\n    :type j: Integer\n    :rtype: Integer\n=end\n    def sum_range(i, j)","lang":"Ruby"},{"s":"class NumArray {\n \n    init(_ nums: [Int]) {\n        \n    }\n    \n    func update(_ i: Int, _ val: Int) {\n        \n    }\n    \n    func sumRange(_ i: Int, _ j: Int) -> Int {\n        \n    }\n}\n \n/**\n * Your NumArray object will be instantiated and \ncalled as such:\n * let obj = NumArray(nums)\n * obj.update(i, val)\n * let ret_2: Int = obj.sumRange(i, j)\n */","lang":"Swift"},{"s":"type NumArray struct {\n \n}\n \n \nfunc Constructor(nums []int) NumArray {\n \n}\n \n \nfunc (this *NumArray) Update(i int, val int)  {\n \n}\n \n \nfunc (this *NumArray) SumRange(i int, j int) int {\n \n}\n \n \n/**\n * Your NumArray object will be instantiated and \ncalled as such:\n * obj := Constructor(nums);\n * obj.Update(i,val);\n * param_2 := obj.SumRange(i,j);","lang":"Go"},{"s":"class NumArray(_nums: Array[Int]) {\n \n    def update(i: Int, `val`: Int) {\n \n    }\n \n    def sumRange(i: Int, j: Int): Int = {\n \n    }\n \n}\n \n/**\n * Your NumArray object will be instantiated and \ncalled as such:\n * var obj = new NumArray(nums)\n * obj.update(i,`val`)\n * var param_2 = obj.sumRange(i,j)\n */","lang":"Scala"},{"s":"class NumArray(nums: IntArray) {\n \n    fun update(i: Int, `val`: Int) {\n \n    }\n \n    fun sumRange(i: Int, j: Int): Int {\n \n    }\n \n}\n \n/**\n * Your NumArray object will be instantiated and \ncalled as such:\n * var obj = NumArray(nums)\n * obj.update(i,`val`)\n * var param_2 = obj.sumRange(i,j)\n */","lang":"Kotlin"},{"s":"struct NumArray {\n \n}\n \n \n/** \n * `&self` means the method takes an immutable \nreference.\n * If you need a mutable reference, change it to `&\nmut self` instead.\n */\nimpl NumArray {\n \n    fn new(nums: Vec<i32>) -> Self {\n        \n    }\n    \n    fn update(&self, i: i32, val: i32) {\n        \n    }\n    \n    fn sum_range(&self, i: i32, j: i32) -> i32 {\n        \n    }\n}\n ","lang":"Rust"},{"s":"class NumArray {\n    /**\n     * @param Integer[] $nums\n     */\n    function __construct($nums) {\n        \n    }\n  \n    /**\n     * @param Integer $i\n     * @param Integer $val\n     * @return NULL\n     */\n    function update($i, $val) {\n        \n    }\n  \n    /**\n     * @param Integer $i\n     * @param Integer $j\n     * @return Integer\n     */\n    function sumRange($i, $j) {\n        \n    }\n}","lang":"PHP"},{"s":"class NumArray {\n    /**\n     * @param Integer[] $nums\n     */\n    function __construct($nums) {\n        \n    }\n  \n    /**\n     * @param Integer $i\n     * @param Integer $val\n     * @return NULL\n     */\n    function update($i, $val) {\n        \n    }\n  \n    /**\n     * @param Integer $i\n     * @param Integer $j\n     * @return Integer\n     */\n    function sumRange($i, $j) {\n        \n    }\n}","lang":"PHP"}],"page":"307/1581","h":"307. 区域和检索 - 数组可修改","d":"<div class=\"notranslate\"><p>给定一个整数数组 &nbsp;<em>nums</em>，求出数组从索引&nbsp;<em>i&nbsp;</em>到&nbsp;<em>j&nbsp;&nbsp;</em>(<em>i</em>&nbsp;≤&nbsp;<em>j</em>) 范围内元素的总和，包含&nbsp;<em>i,&nbsp; j&nbsp;</em>两点。</p>\n\n<p><em>update(i, val)</em> 函数可以通过将下标为&nbsp;<em>i&nbsp;</em>的数值更新为&nbsp;<em>val</em>，从而对数列进行修改。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre>Given nums = [1, 3, 5]\n\nsumRange(0, 2) -&gt; 9\nupdate(1, 2)\nsumRange(0, 2) -&gt; 8\n</pre>\n\n<p><strong>说明:</strong></p>\n\n<ol>\n\t<li>数组仅可以在&nbsp;<em>update&nbsp;</em>函数下进行修改。</li>\n\t<li>你可以假设 <em>update</em> 函数与 <em>sumRange</em> 函数的调用次数是均匀分布的。</li>\n</ol>\n</div>","l":"中等","s":"class NumArray\n \n=begin\n    :type nums: Integer[]\n=end\n    def initialize(nums)\n \n    end\n \n \n=begin\n    :type i: Integer\n    :type val: Integer\n    :rtype: Void\n=end\n    def update(i, val)\n \n    end\n \n \n=begin\n    :type i: Integer\n    :type j: Integer\n    :rtype: Integer\n=end\n    def sum_range(i, j)","lang":"Ruby","href":"https://leetcode-cn.com/problems/range-sum-query-mutable/","bb":{"x":445,"y":40,"w":116,"h":28}}

