{"ls":[{"s":"class Solution {\n    public int minSwap(int[] A, int[] B) {\n \n    }\n}","lang":"Java"},{"s":"class Solution(object):\n    def minSwap(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: int\n        \"\"\"","lang":"Python"},{"s":"class Solution:\n    def minSwap(self, A: List[int], B: List[int]) \n-> int:","lang":"Python3"},{"s":"int minSwap(int* A, int ASize, int* B, int BSize){\n \n}","lang":"C"},{"s":"public class Solution {\n    public int MinSwap(int[] A, int[] B) {\n \n    }\n}","lang":"C#"},{"s":"/**\n * @param {number[]} A\n * @param {number[]} B\n * @return {number}\n */\nvar minSwap = function(A, B) {\n \n};","lang":"JavaScript"},{"s":"# @param {Integer[]} a\n# @param {Integer[]} b\n# @return {Integer}\ndef min_swap(a, b)\n \nend","lang":"Ruby"},{"s":"class Solution {\n    func minSwap(_ A: [Int], _ B: [Int]) -> Int {\n        \n    }\n}","lang":"Swift"},{"s":"func minSwap(A []int, B []int) int {\n \n}","lang":"Go"},{"s":"object Solution {\n    def minSwap(A: Array[Int], B: Array[Int]): Int \n= {\n \n    }\n}","lang":"Scala"},{"s":"class Solution {\n    fun minSwap(A: IntArray, B: IntArray): Int {\n \n    }\n}","lang":"Kotlin"},{"s":"impl Solution {\n    pub fn min_swap(a: Vec<i32>, b: Vec<i32>) -> \ni32 {\n        \n    }\n}","lang":"Rust"},{"s":"class Solution {\n \n    /**\n     * @param Integer[] $A\n     * @param Integer[] $B\n     * @return Integer\n     */\n    function minSwap($A, $B) {\n        \n    }\n}","lang":"PHP"},{"s":"class Solution {\n \n    /**\n     * @param Integer[] $A\n     * @param Integer[] $B\n     * @return Integer\n     */\n    function minSwap($A, $B) {\n        \n    }\n}","lang":"PHP"}],"page":"801/1581","h":"801. 使序列递增的最小交换次数","d":"<div class=\"notranslate\"><p>我们有两个长度相等且不为空的整型数组&nbsp;<code>A</code>&nbsp;和&nbsp;<code>B</code>&nbsp;。</p>\n\n<p>我们可以交换&nbsp;<code>A[i]</code>&nbsp;和&nbsp;<code>B[i]</code>&nbsp;的元素。注意这两个元素在各自的序列中应该处于相同的位置。</p>\n\n<p>在交换过一些元素之后，数组&nbsp;<code>A</code>&nbsp;和&nbsp;<code>B</code>&nbsp;都应该是严格递增的（数组严格递增的条件仅为<code>A[0] &lt; A[1] &lt; A[2] &lt; ... &lt; A[A.length - 1]</code>）。</p>\n\n<p>给定数组&nbsp;<code>A</code>&nbsp;和&nbsp;<code>B</code>&nbsp;，请返回使得两个数组均保持严格递增状态的最小交换次数。假设给定的输入总是有效的。</p>\n\n<pre><strong>示例:</strong>\n<strong>输入:</strong> A = [1,3,5,4], B = [1,2,3,7]\n<strong>输出:</strong> 1\n<strong>解释: </strong>\n交换 A[3] 和 B[3] 后，两个数组如下:\nA = [1, 3, 5, 7] ， B = [1, 2, 3, 4]\n两个数组均为严格递增的。</pre>\n\n<p><strong>注意:</strong></p>\n\n<ul>\n\t<li><code>A, B</code>&nbsp;两个数组的长度总是相等的，且长度的范围为&nbsp;<code>[1, 1000]</code>。</li>\n\t<li><code>A[i], B[i]</code>&nbsp;均为&nbsp;<code>[0, 2000]</code>区间内的整数。</li>\n</ul>\n</div>","l":"中等","s":"# @param {Integer[]} a\n# @param {Integer[]} b\n# @return {Integer}\ndef min_swap(a, b)\n \nend","lang":"Ruby","href":"https://leetcode-cn.com/problems/minimum-swaps-to-make-sequences-increasing/","bb":{"x":445,"y":40,"w":116,"h":28}}

