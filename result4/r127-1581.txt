{"ls":[{"s":"# @param {String} begin_word\n# @param {String} end_word\n# @param {String[]} word_list\n# @return {Integer}\ndef ladder_length(begin_word, end_word, word_list)\n \nend","lang":"Ruby"},{"s":"class Solution {\n    func ladderLength(_ beginWord: String, _ \nendWord: String, _ wordList: [String]) -> Int {\n \n    }\n}","lang":"Swift"},{"s":"func ladderLength(beginWord string, endWord string, \nwordList []string) int {\n \n}","lang":"Go"},{"s":"object Solution {\n    def ladderLength(beginWord: String, endWord: \nString, wordList: List[String]): Int = {\n \n    }\n}","lang":"Scala"},{"s":"class Solution {\n    fun ladderLength(beginWord: String, endWord: \nString, wordList: List<String>): Int {\n \n    }\n}","lang":"Kotlin"},{"s":"impl Solution {\n    pub fn ladder_length(begin_word: String, \nend_word: String, word_list: Vec<String>) -> i32 {\n \n    }\n}","lang":"Rust"},{"s":"class Solution {\n    public int ladderLength(String beginWord, \nString endWord, List<String> wordList) {\n \n    }\n}","lang":"Java"},{"s":"class Solution(object):\n    def ladderLength(self, beginWord, endWord, \nwordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"","lang":"Python"},{"s":"class Solution:\n    def ladderLength(self, beginWord: str, endWord: \nstr, wordList: List[str]) -> int:","lang":"Python3"},{"s":"int ladderLength(char * beginWord, char * endWord, \nchar ** wordList, int wordListSize){\n \n}","lang":"C"},{"s":"public class Solution {\n    public int LadderLength(string beginWord, \nstring endWord, IList<string> wordList) {\n \n    }\n}","lang":"C#"},{"s":"/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {number}\n */\nvar ladderLength = function(beginWord, endWord, \nwordList) {\n \n};","lang":"JavaScript"},{"s":"# @param {String} begin_word\n# @param {String} end_word\n# @param {String[]} word_list\n# @return {Integer}\ndef ladder_length(begin_word, end_word, word_list)\n \nend","lang":"Ruby"},{"s":"# @param {String} begin_word\n# @param {String} end_word\n# @param {String[]} word_list\n# @return {Integer}\ndef ladder_length(begin_word, end_word, word_list)\n \nend","lang":"Ruby"}],"page":"127/1581","h":"127. 单词接龙","d":"<div class=\"notranslate\"><p>给定两个单词（<em>beginWord&nbsp;</em>和 <em>endWord</em>）和一个字典，找到从&nbsp;<em>beginWord</em> 到&nbsp;<em>endWord</em> 的最短转换序列的长度。转换需遵循如下规则：</p>\n\n<ol>\n\t<li>每次转换只能改变一个字母。</li>\n\t<li>转换过程中的中间单词必须是字典中的单词。</li>\n</ol>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li>如果不存在这样的转换序列，返回 0。</li>\n\t<li>所有单词具有相同的长度。</li>\n\t<li>所有单词只由小写字母组成。</li>\n\t<li>字典中不存在重复的单词。</li>\n\t<li>你可以假设 <em>beginWord</em> 和 <em>endWord </em>是非空的，且二者不相同。</li>\n</ul>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong>\nbeginWord = \"hit\",\nendWord = \"cog\",\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n\n<strong>输出: </strong>5\n\n<strong>解释: </strong>一个最短转换序列是 \"hit\" -&gt; \"hot\" -&gt; \"dot\" -&gt; \"dog\" -&gt; \"cog\",\n     返回它的长度 5。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong>\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n\n<strong>输出:</strong>&nbsp;0\n\n<strong>解释:</strong>&nbsp;<em>endWord</em> \"cog\" 不在字典中，所以无法进行转换。</pre>\n</div>","l":"中等","s":"class Solution {","lang":"PHP","href":"https://leetcode-cn.com/problems/word-ladder/","bb":{"x":445,"y":40,"w":116,"h":28}}

