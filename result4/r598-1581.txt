{"ls":[{"s":"class Solution {\n    public int maxCount(int m, int n, int[][] ops) {\n \n    }\n}","lang":"Java"},{"s":"class Solution(object):\n    def maxCount(self, m, n, ops):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type ops: List[List[int]]\n        :rtype: int\n        \"\"\"","lang":"Python"},{"s":"class Solution:\n    def maxCount(self, m: int, n: int, ops: List\n[List[int]]) -> int:","lang":"Python3"},{"s":"int maxCount(int m, int n, int** ops, int opsSize, \nint* opsColSize){\n \n}","lang":"C"},{"s":"public class Solution {\n    public int MaxCount(int m, int n, int[][] ops) {\n \n    }\n}","lang":"C#"},{"s":"/**\n * @param {number} m\n * @param {number} n\n * @param {number[][]} ops\n * @return {number}\n */\nvar maxCount = function(m, n, ops) {\n \n};","lang":"JavaScript"},{"s":"# @param {Integer} m\n# @param {Integer} n\n# @param {Integer[][]} ops\n# @return {Integer}\ndef max_count(m, n, ops)\n \nend","lang":"Ruby"},{"s":"class Solution {\n    func maxCount(_ m: Int, _ n: Int, _ ops: [[Int]]\n) -> Int {\n        \n    }\n}","lang":"Swift"},{"s":"func maxCount(m int, n int, ops [][]int) int {\n \n}","lang":"Go"},{"s":"object Solution {\n    def maxCount(m: Int, n: Int, ops: Array[Array\n[Int]]): Int = {\n \n    }\n}","lang":"Scala"},{"s":"class Solution {\n    fun maxCount(m: Int, n: Int, ops: \nArray<IntArray>): Int {\n \n    }\n}","lang":"Kotlin"},{"s":"impl Solution {\n    pub fn max_count(m: i32, n: i32, ops: \nVec<Vec<i32>>) -> i32 {\n        \n    }\n}","lang":"Rust"},{"s":"class Solution {\n \n    /**\n     * @param Integer $m\n     * @param Integer $n\n     * @param Integer[][] $ops\n     * @return Integer\n     */\n    function maxCount($m, $n, $ops) {\n        \n    }\n}","lang":"PHP"},{"s":"class Solution {\n \n    /**\n     * @param Integer $m\n     * @param Integer $n\n     * @param Integer[][] $ops\n     * @return Integer\n     */\n    function maxCount($m, $n, $ops) {\n        \n    }\n}","lang":"PHP"}],"page":"598/1581","h":"598. 范围求和 II","d":"<div class=\"notranslate\"><p>给定一个初始元素全部为&nbsp;<strong>0</strong>，大小为 m*n 的矩阵&nbsp;<strong>M&nbsp;</strong>以及在&nbsp;<strong>M&nbsp;</strong>上的一系列更新操作。</p>\n\n<p>操作用二维数组表示，其中的每个操作用一个含有两个<strong>正整数&nbsp;a</strong> 和 <strong>b</strong> 的数组表示，含义是将所有符合&nbsp;<strong>0 &lt;= i &lt; a</strong> 以及 <strong>0 &lt;= j &lt; b</strong> 的元素&nbsp;<strong>M[i][j]&nbsp;</strong>的值都<strong>增加 1</strong>。</p>\n\n<p>在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> \nm = 3, n = 3\noperations = [[2,2],[3,3]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> \n初始状态, M = \n[[0, 0, 0],\n [0, 0, 0],\n [0, 0, 0]]\n\n执行完操作 [2,2] 后, M = \n[[1, 1, 0],\n [1, 1, 0],\n [0, 0, 0]]\n\n执行完操作 [3,3] 后, M = \n[[2, 2, 1],\n [2, 2, 1],\n [1, 1, 1]]\n\nM 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。\n</pre>\n\n<p><strong>注意:</strong></p>\n\n<ol>\n\t<li>m 和 n 的范围是&nbsp;[1,40000]。</li>\n\t<li>a 的范围是 [1,m]，b 的范围是 [1,n]。</li>\n\t<li>操作数目不超过 10000。</li>\n</ol>\n</div>","l":"简单","s":"class Solution {\npublic:\n    int maxCount(int m, int n, vector<vector<int>>& \nops) {\n \n    }\n};","lang":"C++","href":"https://leetcode-cn.com/problems/range-addition-ii/","bb":{"x":445,"y":40,"w":116,"h":28}}

