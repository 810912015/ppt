{"ls":[{"s":"class ExamRoom\n \n=begin\n    :type n: Integer\n=end\n    def initialize(n)\n \n    end\n \n \n=begin\n    :rtype: Integer\n=end\n    def seat()\n \n    end\n \n \n=begin\n    :type p: Integer\n    :rtype: Void\n=end\n    def leave(p)\n \n    end\n ","lang":"Ruby"},{"s":"class ExamRoom {\n \n    init(_ N: Int) {\n        \n    }\n    \n    func seat() -> Int {\n        \n    }\n    \n    func leave(_ p: Int) {\n        \n    }\n}\n \n/**\n * Your ExamRoom object will be instantiated and \ncalled as such:\n * let obj = ExamRoom(N)\n * let ret_1: Int = obj.seat()\n * obj.leave(p)\n */","lang":"Swift"},{"s":"type ExamRoom struct {\n \n}\n \n \nfunc Constructor(N int) ExamRoom {\n \n}\n \n \nfunc (this *ExamRoom) Seat() int {\n \n}\n \n \nfunc (this *ExamRoom) Leave(p int)  {\n \n}\n \n \n/**\n * Your ExamRoom object will be instantiated and \ncalled as such:\n * obj := Constructor(N);\n * param_1 := obj.Seat();\n * obj.Leave(p);","lang":"Go"},{"s":"class ExamRoom(_N: Int) {\n \n    def seat(): Int = {\n \n    }\n \n    def leave(p: Int) {\n \n    }\n \n}\n \n/**\n * Your ExamRoom object will be instantiated and \ncalled as such:\n * var obj = new ExamRoom(N)\n * var param_1 = obj.seat()\n * obj.leave(p)\n */","lang":"Scala"},{"s":"class ExamRoom(N: Int) {\n \n    fun seat(): Int {\n \n    }\n \n    fun leave(p: Int) {\n \n    }\n \n}\n \n/**\n * Your ExamRoom object will be instantiated and \ncalled as such:\n * var obj = ExamRoom(N)\n * var param_1 = obj.seat()\n * obj.leave(p)\n */","lang":"Kotlin"},{"s":"struct ExamRoom {\n \n}\n \n \n/** \n * `&self` means the method takes an immutable \nreference.\n * If you need a mutable reference, change it to `&\nmut self` instead.\n */\nimpl ExamRoom {\n \n    fn new(N: i32) -> Self {\n        \n    }\n    \n    fn seat(&self) -> i32 {\n        \n    }\n    \n    fn leave(&self, p: i32) {\n        \n    }\n}\n ","lang":"Rust"},{"s":"class ExamRoom {\n \n    public ExamRoom(int N) {\n \n    }\n    \n    public int seat() {\n \n    }\n    \n    public void leave(int p) {\n \n    }\n}\n \n/**\n * Your ExamRoom object will be instantiated and \ncalled as such:\n * ExamRoom obj = new ExamRoom(N);\n * int param_1 = obj.seat();\n * obj.leave(p);\n */","lang":"Java"},{"s":"class ExamRoom {\n \n    public ExamRoom(int N) {\n \n    }\n    \n    public int seat() {\n \n    }\n    \n    public void leave(int p) {\n \n    }\n}\n \n/**\n * Your ExamRoom object will be instantiated and \ncalled as such:\n * ExamRoom obj = new ExamRoom(N);\n * int param_1 = obj.seat();\n * obj.leave(p);\n */","lang":"Java"},{"s":"class ExamRoom:\n \n    def __init__(self, N: int):\n        \n \n    def seat(self) -> int:\n        \n \n    def leave(self, p: int) -> None:\n        \n \n \n# Your ExamRoom object will be instantiated and \ncalled as such:\n# obj = ExamRoom(N)\n# param_1 = obj.seat()\n# obj.leave(p)","lang":"Python3"},{"s":"typedef struct {\n    \n} ExamRoom;\n \n \nExamRoom* examRoomCreate(int N) {\n    \n}\n \nint examRoomSeat(ExamRoom* obj) {\n  \n}\n \nvoid examRoomLeave(ExamRoom* obj, int p) {\n  \n}\n \nvoid examRoomFree(ExamRoom* obj) {\n    \n}\n \n/**\n * Your ExamRoom struct will be instantiated and \ncalled as such:\n * ExamRoom* obj = examRoomCreate(N);\n * int param_1 = examRoomSeat(obj);","lang":"C"},{"s":"public class ExamRoom {\n \n    public ExamRoom(int N) {\n \n    }\n    \n    public int Seat() {\n \n    }\n    \n    public void Leave(int p) {\n \n    }\n}\n \n/**\n * Your ExamRoom object will be instantiated and \ncalled as such:\n * ExamRoom obj = new ExamRoom(N);\n * int param_1 = obj.Seat();\n * obj.Leave(p);\n */","lang":"C#"},{"s":"/**\n * @param {number} N\n */\nvar ExamRoom = function(N) {\n \n};\n \n/**\n * @return {number}\n */\nExamRoom.prototype.seat = function() {\n \n};\n \n/** \n * @param {number} p\n * @return {void}\n */\nExamRoom.prototype.leave = function(p) {\n \n};\n \n/**\n * Your ExamRoom object will be instantiated and \ncalled as such:\n * var obj = new ExamRoom(N)","lang":"JavaScript"},{"s":"class ExamRoom\n \n=begin\n    :type n: Integer\n=end\n    def initialize(n)\n \n    end\n \n \n=begin\n    :rtype: Integer\n=end\n    def seat()\n \n    end\n \n \n=begin\n    :type p: Integer\n    :rtype: Void\n=end\n    def leave(p)\n \n    end\n ","lang":"Ruby"},{"s":"class ExamRoom\n \n=begin\n    :type n: Integer\n=end\n    def initialize(n)\n \n    end\n \n \n=begin\n    :rtype: Integer\n=end\n    def seat()\n \n    end\n \n \n=begin\n    :type p: Integer\n    :rtype: Void\n=end\n    def leave(p)\n \n    end\n ","lang":"Ruby"}],"page":"855/1581","h":"855. 考场就座","d":"<div class=\"notranslate\"><p>在考场里，一排有&nbsp;<code>N</code>&nbsp;个座位，分别编号为&nbsp;<code>0, 1, 2, ..., N-1</code>&nbsp;。</p>\n\n<p>当学生进入考场后，他必须坐在能够使他与离他最近的人之间的距离达到最大化的座位上。如果有多个这样的座位，他会坐在编号最小的座位上。(另外，如果考场里没有人，那么学生就坐在 0 号座位上。)</p>\n\n<p>返回&nbsp;<code>ExamRoom(int N)</code>&nbsp;类，它有两个公开的函数：其中，函数&nbsp;<code>ExamRoom.seat()</code>&nbsp;会返回一个&nbsp;<code>int</code>&nbsp;（整型数据），代表学生坐的位置；函数&nbsp;<code>ExamRoom.leave(int p)</code>&nbsp;代表坐在座位 <code>p</code> 上的学生现在离开了考场。每次调用&nbsp;<code>ExamRoom.leave(p)</code>&nbsp;时都保证有学生坐在座位&nbsp;<code>p</code>&nbsp;上。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>[\"ExamRoom\",\"seat\",\"seat\",\"seat\",\"seat\",\"leave\",\"seat\"], [[10],[],[],[],[],[4],[]]\n<strong>输出：</strong>[null,0,9,4,2,null,5]\n<strong>解释：</strong>\nExamRoom(10) -&gt; null\nseat() -&gt; 0，没有人在考场里，那么学生坐在 0 号座位上。\nseat() -&gt; 9，学生最后坐在 9 号座位上。\nseat() -&gt; 4，学生最后坐在 4 号座位上。\nseat() -&gt; 2，学生最后坐在 2 号座位上。\nleave(4) -&gt; null\nseat() -&gt; 5，学生最后坐在 5 号座位上。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= N &lt;= 10^9</code></li>\n\t<li>在所有的测试样例中&nbsp;<code>ExamRoom.seat()</code>&nbsp;和&nbsp;<code>ExamRoom.leave()</code>&nbsp;最多被调用&nbsp;<code>10^4</code>&nbsp;次。</li>\n\t<li>保证在调用&nbsp;<code>ExamRoom.leave(p)</code>&nbsp;时有学生正坐在座位 <code>p</code> 上。</li>\n</ol>\n</div>","l":"中等","s":"","lang":"PHP","href":"https://leetcode-cn.com/problems/exam-room/","bb":{"x":445,"y":40,"w":116,"h":28}}

