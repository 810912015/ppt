{"ls":[{"s":"class MyQueue\n \n=begin\n    Initialize your data structure here.\n=end\n    def initialize()\n \n    end\n \n \n=begin\n    Push element x to the back of queue.\n    :type x: Integer\n    :rtype: Void\n=end\n    def push(x)\n \n    end\n \n \n=begin\n    Removes the element from in front of queue and \nreturns that element.\n    :rtype: Integer\n=end\n    def pop()","lang":"Ruby"},{"s":"class MyQueue {\n \n    /** Initialize your data structure here. */\n    init() {\n \n    }\n    \n    /** Push element x to the back of queue. */\n    func push(_ x: Int) {\n \n    }\n    \n    /** Removes the element from in front of queue \nand returns that element. */\n    func pop() -> Int {\n \n    }\n    \n    /** Get the front element. */\n    func peek() -> Int {\n \n    }\n    \n    /** Returns whether the queue is empty. */\n    func empty() -> Bool {\n ","lang":"Swift"},{"s":"type MyQueue struct {\n \n}\n \n \n/** Initialize your data structure here. */\nfunc Constructor() MyQueue {\n \n}\n \n \n/** Push element x to the back of queue. */\nfunc (this *MyQueue) Push(x int)  {\n \n}\n \n \n/** Removes the element from in front of queue and \nreturns that element. */\nfunc (this *MyQueue) Pop() int {\n \n}\n \n \n/** Get the front element. */\nfunc (this *MyQueue) Peek() int {","lang":"Go"},{"s":"class MyQueue() {\n \n    /** Initialize your data structure here. */\n \n \n    /** Push element x to the back of queue. */\n    def push(x: Int) {\n \n    }\n \n    /** Removes the element from in front of queue \nand returns that element. */\n    def pop(): Int = {\n \n    }\n \n    /** Get the front element. */\n    def peek(): Int = {\n \n    }\n \n    /** Returns whether the queue is empty. */\n    def empty(): Boolean = {\n \n    }\n ","lang":"Scala"},{"s":"class MyQueue() {\n \n    /** Initialize your data structure here. */\n \n \n    /** Push element x to the back of queue. */\n    fun push(x: Int) {\n \n    }\n \n    /** Removes the element from in front of queue \nand returns that element. */\n    fun pop(): Int {\n \n    }\n \n    /** Get the front element. */\n    fun peek(): Int {\n \n    }\n \n    /** Returns whether the queue is empty. */\n    fun empty(): Boolean {\n \n    }\n ","lang":"Kotlin"},{"s":"struct MyQueue {\n \n}\n \n \n/**\n * `&self` means the method takes an immutable \nreference.\n * If you need a mutable reference, change it to `&\nmut self` instead.\n */\nimpl MyQueue {\n \n    /** Initialize your data structure here. */\n    fn new() -> Self {\n \n    }\n    \n    /** Push element x to the back of queue. */\n    fn push(&self, x: i32) {\n \n    }\n    \n    /** Removes the element from in front of queue \nand returns that element. */\n    fn pop(&self) -> i32 {","lang":"Rust"},{"s":"class MyQueue {\n \n    /** Initialize your data structure here. */\n    public MyQueue() {\n \n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n \n    }\n    \n    /** Removes the element from in front of queue \nand returns that element. */\n    public int pop() {\n \n    }\n    \n    /** Get the front element. */\n    public int peek() {\n \n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n ","lang":"Java"},{"s":"class MyQueue(object):\n \n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n \n \n    def push(self, x):\n        \"\"\"\n        Push element x to the back of queue.\n        :type x: int\n        :rtype: None\n        \"\"\"\n \n \n    def pop(self):\n        \"\"\"\n        Removes the element from in front of queue \nand returns that element.\n        :rtype: int\n        \"\"\"\n \n \n    def peek(self):\n        \"\"\"","lang":"Python"},{"s":"class MyQueue:\n \n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n \n \n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n \n \n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue \nand returns that element.\n        \"\"\"\n \n \n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n ","lang":"Python3"},{"s":"typedef struct {\n \n} MyQueue;\n \n/** Initialize your data structure here. */\n \nMyQueue* myQueueCreate() {\n \n}\n \n/** Push element x to the back of queue. */\nvoid myQueuePush(MyQueue* obj, int x) {\n \n}\n \n/** Removes the element from in front of queue and \nreturns that element. */\nint myQueuePop(MyQueue* obj) {\n \n}\n \n/** Get the front element. */\nint myQueuePeek(MyQueue* obj) {\n \n}\n ","lang":"C"},{"s":"public class MyQueue {\n \n    /** Initialize your data structure here. */\n    public MyQueue() {\n \n    }\n    \n    /** Push element x to the back of queue. */\n    public void Push(int x) {\n \n    }\n    \n    /** Removes the element from in front of queue \nand returns that element. */\n    public int Pop() {\n \n    }\n    \n    /** Get the front element. */\n    public int Peek() {\n \n    }\n    \n    /** Returns whether the queue is empty. */\n    public bool Empty() {\n ","lang":"C#"},{"s":"/**\n * Initialize your data structure here.\n */\nvar MyQueue = function() {\n \n};\n \n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n \n};\n \n/**\n * Removes the element from in front of queue and \nreturns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n \n};\n \n/**","lang":"JavaScript"},{"s":"class MyQueue\n \n=begin\n    Initialize your data structure here.\n=end\n    def initialize()\n \n    end\n \n \n=begin\n    Push element x to the back of queue.\n    :type x: Integer\n    :rtype: Void\n=end\n    def push(x)\n \n    end\n \n \n=begin\n    Removes the element from in front of queue and \nreturns that element.\n    :rtype: Integer\n=end\n    def pop()","lang":"Ruby"},{"s":"class MyQueue\n \n=begin\n    Initialize your data structure here.\n=end\n    def initialize()\n \n    end\n \n \n=begin\n    Push element x to the back of queue.\n    :type x: Integer\n    :rtype: Void\n=end\n    def push(x)\n \n    end\n \n \n=begin\n    Removes the element from in front of queue and \nreturns that element.\n    :rtype: Integer\n=end\n    def pop()","lang":"Ruby"}],"page":"232/1581","h":"232. 用栈实现队列","d":"<div class=\"notranslate\"><p>使用栈实现队列的下列操作：</p>\n\n<ul>\n\t<li>push(x) -- 将一个元素放入队列的尾部。</li>\n\t<li>pop() -- 从队列首部移除元素。</li>\n\t<li>peek() -- 返回队列首部的元素。</li>\n\t<li>empty() -- 返回队列是否为空。</li>\n</ul>\n\n<p><strong>示例:</strong></p>\n\n<pre>MyQueue queue = new MyQueue();\n\nqueue.push(1);\nqueue.push(2);  \nqueue.peek();  // 返回 1\nqueue.pop();   // 返回 1\nqueue.empty(); // 返回 false</pre>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li>你只能使用标准的栈操作 -- 也就是只有&nbsp;<code>push to top</code>,&nbsp;<code>peek/pop from top</code>,&nbsp;<code>size</code>, 和&nbsp;<code>is empty</code>&nbsp;操作是合法的。</li>\n\t<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>\n\t<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li>\n</ul>\n</div>","l":"简单","s":"class MyQueue {\n    /**\n     * Initialize your data structure here.\n     */\n    function __construct() {\n \n    }\n \n    /**\n     * Push element x to the back of queue.\n     * @param Integer $x\n     * @return NULL\n     */\n    function push($x) {\n \n    }\n \n    /**\n     * Removes the element from in front of queue \nand returns that element.\n     * @return Integer\n     */\n    function pop() {\n \n    }\n ","lang":"PHP","href":"https://leetcode-cn.com/problems/implement-queue-using-stacks/","bb":{"x":445,"y":40,"w":116,"h":28}}

