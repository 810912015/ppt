{"ls":[{"s":"class Solution {\n    public List<Integer> findMinHeightTrees(int n, \nint[][] edges) {\n \n    }\n}","lang":"Java"},{"s":"class Solution(object):\n    def findMinHeightTrees(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"","lang":"Python"},{"s":"class Solution:\n    def findMinHeightTrees(self, n: int, edges: List\n[List[int]]) -> List[int]:","lang":"Python3"},{"s":"/**\n * Note: The returned array must be malloced, \nassume caller calls free().\n */\nint* findMinHeightTrees(int n, int** edges, int \nedgesSize, int* edgesColSize, int* returnSize){\n \n}","lang":"C"},{"s":"public class Solution {\n    public IList<int> FindMinHeightTrees(int n, int\n[][] edges) {\n \n    }\n}","lang":"C#"},{"s":"/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number[]}\n */\nvar findMinHeightTrees = function(n, edges) {\n \n};","lang":"JavaScript"},{"s":"# @param {Integer} n\n# @param {Integer[][]} edges\n# @return {Integer[]}\ndef find_min_height_trees(n, edges)\n \nend","lang":"Ruby"},{"s":"class Solution {\n    func findMinHeightTrees(_ n: Int, _ edges: [\n[Int]]) -> [Int] {\n        \n    }\n}","lang":"Swift"},{"s":"func findMinHeightTrees(n int, edges [][]int) []int \n{\n \n}","lang":"Go"},{"s":"object Solution {\n    def findMinHeightTrees(n: Int, edges: Array\n[Array[Int]]): List[Int] = {\n \n    }\n}","lang":"Scala"},{"s":"class Solution {\n    fun findMinHeightTrees(n: Int, edges: \nArray<IntArray>): List<Int> {\n \n    }\n}","lang":"Kotlin"},{"s":"impl Solution {\n    pub fn find_min_height_trees(n: i32, edges: \nVec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}","lang":"Rust"},{"s":"class Solution {\n \n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @return Integer[]\n     */\n    function findMinHeightTrees($n, $edges) {\n        \n    }\n}","lang":"PHP"},{"s":"class Solution {\n \n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @return Integer[]\n     */\n    function findMinHeightTrees($n, $edges) {\n        \n    }\n}","lang":"PHP"}],"page":"310/1581","h":"310. 最小高度树","d":"<div class=\"notranslate\"><p>对于一个具有树特征的无向图，我们可选择任何一个节点作为根。图因此可以成为树，在所有可能的树中，具有最小高度的树被称为最小高度树。给出这样的一个图，写出一个函数找到所有的最小高度树并返回他们的根节点。</p>\n\n<p><strong>格式</strong></p>\n\n<p>该图包含&nbsp;<code>n</code>&nbsp;个节点，标记为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>。给定数字&nbsp;<code>n</code>&nbsp;和一个无向边&nbsp;<code>edges</code>&nbsp;列表（每一个边都是一对标签）。</p>\n\n<p>你可以假设没有重复的边会出现在&nbsp;<code>edges</code>&nbsp;中。由于所有的边都是无向边， <code>[0, 1]</code>和&nbsp;<code>[1, 0]</code>&nbsp;是相同的，因此不会同时出现在&nbsp;<code>edges</code>&nbsp;里。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> <code>n = 4</code>, <code>edges = [[1, 0], [1, 2], [1, 3]]</code>\n\n        0\n        |\n        1\n       / \\\n      2   3 \n\n<strong>输出:</strong> <code>[1]</code>\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> <code>n = 6</code>, <code>edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</code>\n\n     0  1  2\n      \\ | /\n        3\n        |\n        4\n        |\n        5 \n\n<strong>输出:</strong> <code>[3, 4]</code></pre>\n\n<p><strong>说明</strong>:</p>\n\n<ul>\n\t<li>&nbsp;根据<a href=\"https://baike.baidu.com/item/%E6%A0%91/2699484?fromtitle=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84+%E6%A0%91&amp;fromid=12062173&amp;fr=aladdin\">树的定义</a>，树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。</li>\n\t<li>树的高度是指根节点和叶子节点之间最长向下路径上边的数量。</li>\n</ul>\n</div>","l":"中等","s":"# @param {Integer} n\n# @param {Integer[][]} edges\n# @return {Integer[]}\ndef find_min_height_trees(n, edges)\n \nend","lang":"Ruby","href":"https://leetcode-cn.com/problems/minimum-height-trees/","bb":{"x":445,"y":40,"w":116,"h":28}}

