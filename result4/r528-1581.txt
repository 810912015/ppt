{"ls":[{"s":"class Solution\n \n=begin\n    :type w: Integer[]\n=end\n    def initialize(w)\n \n    end\n \n \n=begin\n    :rtype: Integer\n=end\n    def pick_index()\n \n    end\n \n \nend\n \n# Your Solution object will be instantiated and \ncalled as such:\n# obj = Solution.new(w)\n# param_1 = obj.pick_index()","lang":"Ruby"},{"s":"class Solution {\n \n    init(_ w: [Int]) {\n \n    }\n    \n    func pickIndex() -> Int {\n \n    }\n}\n \n/**\n * Your Solution object will be instantiated and \ncalled as such:\n * let obj = Solution(w)\n * let ret_1: Int = obj.pickIndex()\n */","lang":"Swift"},{"s":"type Solution struct {\n \n}\n \n \nfunc Constructor(w []int) Solution {\n \n}\n \n \nfunc (this *Solution) PickIndex() int {\n \n}\n \n \n/**\n * Your Solution object will be instantiated and \ncalled as such:\n * obj := Constructor(w);\n * param_1 := obj.PickIndex();\n */","lang":"Go"},{"s":"class Solution(_w: Array[Int]) {\n \n    def pickIndex(): Int = {\n \n    }\n \n}\n \n/**\n * Your Solution object will be instantiated and \ncalled as such:\n * var obj = new Solution(w)\n * var param_1 = obj.pickIndex()\n */","lang":"Scala"},{"s":"class Solution(w: IntArray) {\n \n    fun pickIndex(): Int {\n \n    }\n \n}\n \n/**\n * Your Solution object will be instantiated and \ncalled as such:\n * var obj = Solution(w)\n * var param_1 = obj.pickIndex()\n */","lang":"Kotlin"},{"s":"struct Solution {\n \n}\n \n \n/**\n * `&self` means the method takes an immutable \nreference.\n * If you need a mutable reference, change it to `&\nmut self` instead.\n */\nimpl Solution {\n \n    fn new(w: Vec<i32>) -> Self {\n \n    }\n    \n    fn pick_index(&self) -> i32 {\n \n    }\n}\n \n/**\n * Your Solution object will be instantiated and \ncalled as such:\n * let obj = Solution::new(w);","lang":"Rust"},{"s":"class Solution {\n \n    public Solution(int[] w) {\n \n    }\n    \n    public int pickIndex() {\n \n    }\n}\n \n/**\n * Your Solution object will be instantiated and \ncalled as such:\n * Solution obj = new Solution(w);\n * int param_1 = obj.pickIndex();\n */","lang":"Java"},{"s":"class Solution(object):\n \n    def __init__(self, w):\n        \"\"\"\n        :type w: List[int]\n        \"\"\"\n        \n \n    def pickIndex(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n \n \n# Your Solution object will be instantiated and \ncalled as such:\n# obj = Solution(w)\n# param_1 = obj.pickIndex()","lang":"Python"},{"s":"class Solution:\n \n    def __init__(self, w: List[int]):\n        \n \n    def pickIndex(self) -> int:\n        \n \n \n# Your Solution object will be instantiated and \ncalled as such:\n# obj = Solution(w)\n# param_1 = obj.pickIndex()","lang":"Python3"},{"s":"typedef struct {\n    \n} Solution;\n \n \nSolution* solutionCreate(int* w, int wSize) {\n    \n}\n \nint solutionPickIndex(Solution* obj) {\n  \n}\n \nvoid solutionFree(Solution* obj) {\n    \n}\n \n/**\n * Your Solution struct will be instantiated and \ncalled as such:\n * Solution* obj = solutionCreate(w, wSize);\n * int param_1 = solutionPickIndex(obj);\n \n * solutionFree(obj);\n*/","lang":"C"},{"s":"public class Solution {\n \n    public Solution(int[] w) {\n \n    }\n    \n    public int PickIndex() {\n \n    }\n}\n \n/**\n * Your Solution object will be instantiated and \ncalled as such:\n * Solution obj = new Solution(w);\n * int param_1 = obj.PickIndex();\n */","lang":"C#"},{"s":"/**\n * @param {number[]} w\n */\nvar Solution = function(w) {\n \n};\n \n/**\n * @return {number}\n */\nSolution.prototype.pickIndex = function() {\n \n};\n \n/**\n * Your Solution object will be instantiated and \ncalled as such:\n * var obj = new Solution(w)\n * var param_1 = obj.pickIndex()\n */","lang":"JavaScript"},{"s":"class Solution\n \n=begin\n    :type w: Integer[]\n=end\n    def initialize(w)\n \n    end\n \n \n=begin\n    :rtype: Integer\n=end\n    def pick_index()\n \n    end\n \n \nend\n \n# Your Solution object will be instantiated and \ncalled as such:\n# obj = Solution.new(w)\n# param_1 = obj.pick_index()","lang":"Ruby"},{"s":"class Solution\n \n=begin\n    :type w: Integer[]\n=end\n    def initialize(w)\n \n    end\n \n \n=begin\n    :rtype: Integer\n=end\n    def pick_index()\n \n    end\n \n \nend\n \n# Your Solution object will be instantiated and \ncalled as such:\n# obj = Solution.new(w)\n# param_1 = obj.pick_index()","lang":"Ruby"}],"page":"528/1581","h":"528. 按权重随机选择","d":"<div class=\"notranslate\"><p>给定一个正整数数组&nbsp;<code>w</code> ，其中&nbsp;<code>w[i]</code>&nbsp;代表位置&nbsp;<code>i</code>&nbsp;的权重，请写一个函数&nbsp;<code>pickIndex</code>&nbsp;，它可以随机地获取位置&nbsp;<code>i</code>，选取位置&nbsp;<code>i</code>&nbsp;的概率与&nbsp;<code>w[i]</code>&nbsp;成正比。</p>\n\n<p>说明:</p>\n\n<ol>\n\t<li><code>1 &lt;= w.length &lt;= 10000</code></li>\n\t<li><code>1 &lt;= w[i] &lt;= 10^5</code></li>\n\t<li><code>pickIndex</code>&nbsp;将被调用不超过&nbsp;<code>10000</code>&nbsp;次</li>\n</ol>\n\n<p><strong>示例1:</strong></p>\n\n<pre><strong>输入: \n</strong>[\"Solution\",\"pickIndex\"]\n[[[1]],[]]\n<strong>输出: </strong>[null,0]\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre><strong>输入: \n</strong>[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"]\n[[[1,3]],[],[],[],[],[]]\n<strong>输出: </strong>[null,0,1,1,1,0]</pre>\n\n<p><strong>输入语法说明：</strong></p>\n\n<p>输入是两个列表：调用成员函数名和调用的参数。<code>Solution</code>&nbsp;的构造函数有一个参数，即数组&nbsp;<code>w</code>。<code>pickIndex</code>&nbsp;没有参数。输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。</p>\n</div>","l":"中等","s":"class Solution {\n    /**\n     * @param Integer[] $w\n     */\n    function __construct($w) {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function pickIndex() {\n        \n    }\n}\n \n/**\n * Your Solution object will be instantiated and \ncalled as such:\n * $obj = Solution($w);\n * $ret_1 = $obj->pickIndex();\n */","lang":"PHP","href":"https://leetcode-cn.com/problems/random-pick-with-weight/","bb":{"x":445,"y":40,"w":116,"h":28}}

